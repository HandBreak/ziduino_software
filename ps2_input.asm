PS2_COUNTER:			; !!!!  Указанные буфера работают только в Shadow RAM, иначе оказываются в R/O области
	defb 00h
PS2_PARITY:			; !!!!  Указанные буфера работают только в Shadow RAM, иначе оказываются в R/O области
	defb 00h 
PS2_REGISTER:			; !!!!  Указанные буфера работают только в Shadow RAM, иначе оказываются в R/O области
	defb 00h
PS2_RAWDATA:			; !!!!  Указанные буфера работают только в Shadow RAM, иначе оказываются в R/O области
	defb 00h
PS2_BUFFER:
	defs 20h		; Буфер данных ввода клавиатуры устанавливаем 32 байта, инициализируем 00 - нет данных
PS2_BUFCNT:
	defb 1fh		; Счетчик свободного пространства буфера (по мере заполнения - уменьшается, 0 - буфер переполнен)
;
; PS/2 Keyboard read
;
PS2_READ:
	ld a,03h		; Устанавливаем D0D1 в 1 для разрешения миниклавиатуры
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2 (KD0,KD1=1), (KD2,KD3 фиксирует данные линии)
	ld bc,0fffeh		; В BC Адрес порта ввода клавиатуры (#FE), строки отключены (#FF)
	in a,(c)		; Читаем содержимое порта
	ld (PS2_RAWDATA),a	; Сохраним состояние линий данных DATA и CLOCK на момент прерывания
	bit 2,a			; Прерывание вызвано CLOCK от PS/2 ?
	ret nz			; выйти из обработчика если не от PS/2
;
	ld hl,PS2_COUNTER	; в HL адрес ячейки счетчика бит
	ld de,PS2_PARITY	; в DE адрес ячейки контроля четности
	and 00001000b		; Оставляем только DATA-bit
	ld c,a			; Сохраним состояние бита DATA в C
	ld a,(hl)		; В A <- COUNTER. Проверим это начало передачи ?
	or a			; Если = 0 значит DATA должен содержать START bit, иначе номер из бита по порядку
	jr nz,PS2_SHIFT		; Переходим к приёму данных, если это не стартовый бит? Иначе A=0
	or c			; DATA = 0 ? (В A всегда 0)
	jr nz,PS2_SV_COUNT	; Если это не стартовый бит, то счётчик не меняем (остаётся 0)
	inc (hl)		; Увеличим счетчик на 1
PS2_SV_COUNT:
	xor a
	ld (PS2_REGISTER),a	; Запишем в регистр данных ввода 0
	ld (de),a		; Обнуляем регистр контроля четности
	ret			; Выйдем из цикла сканирования
;
PS2_SHIFT:
	inc (hl)		; PS2_COUNTER = PS2_COUNTER + 1
	cp 09h			; Пришёл 9-й бит ?  Если да, то
	jr z,PS2_CHECK		; переходим к проверке контрольной суммы, иначе
	cp 0ah			; Если это 10-й бит (STOP-bit), то
	jr z,PS2_END		; переходим к концу процедуры, иначе
	ld a,c			; Восстановии в A состояние DATA
	add 11111000b		; Добавляем до получения переноса CY если DATA=1
	push af			; Сохранить состояние CY
	ld a,(PS2_REGISTER)	; Считаем текущий байт данных в A
	rra			; Сдвигаем CY->bit7->bit0
	ld (PS2_REGISTER),a	; Сохраняем промежуточные данные
	pop af			; Восстановить СY
	ret nc			; Выйти из цикла сканирования,если считанный бит = 0 (DATA=0)
	ld a,(de)		; 
	inc a			; PS2_PARITY = PS2_PARITY + 1  (чёт/нечет)
	ld (de),a		; Сохранить вычисленное значение
	ret			; выйти из цикла сканирования
;
PS2_CHECK:
	ld a,c
	add 11111000b		; В CY <- Бит четности
	ld a,(de)		; Считываем текущее состояние регистра для проверки чётности
	adc a,0			; Суммируем A с CY
	bit 0,a			; Проверяем четность.
	jr z,PS2_CHECK_ERR	; Произошла ошибка контроля чётности ?
	ld a,(PS2_REGISTER)	; Передаём результат в буфер клавиатуры
	call PS2_WRBUF		; Вызвать процедуру записи данных в буфер
;	ld (8006h),a		; Записываем считанный код в буфер вывовода
	ret
;
PS2_CHECK_ERR:
	xor a
	ld (hl),a		; Обнуляем счетчик данных
	ld a,02h		; Устанавливаем D0 в 0 D1 в 1 для сброса контроллераклавиатуры
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2 (KD0,KD1=1), (KD2,KD3 фиксирует данные линии)
	ld b,0ffh		;
PS2_ERR_PAUSE:
	djnz PS2_ERR_PAUSE
	ld a,03h		; Устанавливаем D0D1 в 1 для сброса контроллераклавиатуры
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2 (KD0,KD1=1), (KD2,KD3 фиксирует данные линии)
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2 (KD0,KD1=1), (KD2,KD3 фиксирует данные линии)
	ret
;
PS2_END:
	bit 3,c			; Проверяем состояние DATA, Должен быть 1
;	jr z,PS2_CHECK_ERR	; Если последний бит (DATA) оказался "0", идём на обработку ошибки (это или ошибка или подтверждение приёма данных от компьютера)
	xor a
	ld (hl),a		; Обнуляем счетчик данных
	ret 			; Успешный выход из цикла сканирования

PS2_WRBUF:
	ld b,a			; сохраним сканкод
	ld hl,PS2_BUFCNT	; HL счетчик позиции
	ld de,PS2_BUFFER	; DE Адрес начала буфера
	ld a,(hl)		; загрузим значение счетчика
	or a			; если переполнен, сигналим и выходим из цикла ввода
	jr z,PS2_BUF_OVERFLOW
	ex de,hl		; в HL адрес буфера
	ld c,a			; в C значение счетчика
	ld a,b			; в A восстановим сканкод
	ld b,0			; B-0 для последующего вычисления позиции в буфере
	add hl,bc		; HL = HL + PS2_BUFCNT  (в HL позиция буфера для записи)
	ld (hl),a		; Сохраним полученные данные в буфере
	ex de,hl		; в HL адрес счетчика позиции в буфере
	dec (hl)		; Уменьшим счетчик на 1 (при достижении "0" - буфер будет считаться переполненным, подаём сигнал)
	ret			; Выход из обработчика буфера
;
PS2_BUF_OVERFLOW:
	ld b,0b0h		; Загружаем количество импульсов звука нажатия клавиши. Число должно быть чётным!!!
	jp SYS_BEEP		; Воспроизвести длительный звук	
	
; !!!!!!!!!!!!!!  Код не отлажен и работает некорректно !!!!!!!!!!!!!!!!! 
; PS/2 Send code to keyboard	;A - передаваемый в клавиатуру код
;
PS2_WRITE:
	di			; Запретим прерывания на время формирования управляющих последовательностей
	ld d,a			; Сохраним код данных в регистре d
	ld a,02h		; Устанавливаем D0 в 0 D1 в 1 для активации передачи данных
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2 (KD2,KD3 фиксирует данные линии)
	ld b,7fh		; 127 циклов * 13T = 1651 тактов, при F=16384Mhz ~ 100мкс
PS2_WAIT_CLOCK:
	djnz PS2_WAIT_CLOCK	; выдерживаем паузу в 100 мкс
	xor a			; формируем START-bit
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3 фиксирует данные линии)
	ld b,06h		; 6 циклов * 13T = 78 тактов, ~ 5 мкс
PS2_WAIT_DATA:
	djnz PS2_WAIT_DATA
	ld a,01h		; Устанавливаем D0 в 1 D1 в 0 для фиксации START-bit
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3 фиксирует данные линии)

	ld b,08h		; Инициализируем счётчик передаваемых бит. (10 бит)
	ld e,00h		; Очищаем счетчик чётности
PS2_WRITE_BIT:
	push bc			; сохраняем счетчик бит данных
	call PS2_WAIT_KBD
	ld a,d			; Восстановим код в регистре A
	and 01h			; Оставим только бит данных
	ld c,a			; сохраним Данные в C
	add e			; считаем количество "1"
	ld e,a			; кладём их в E
	ld a,c			; восстанавливаем A
	rlca			; 7..1<-0 переместим отпавляемый бит данных во второй разряд
	or 1			; Младший бит (CLOCK) всегда в 1 - управляется PS2 клавиатурой
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3 фиксирует данные линии)
	srl d			; выбираем следующий по порядку бит данных
	pop bc			; восстанавливаем счетчик бит данных
	djnz PS2_WRITE_BIT	; отправляем данные
	call PS2_WAIT_KBD	; ожидаем очередной CLOCK
	ld a,e			; Загружаем в А количество "1" в переданном байте
	and 1			; Нас интересует только младший разряд (четн/нечетн)
	rlca			; двигаем его во 2-ой разряд
	xor 3			; Младший бит (CLOCK) всегда в 1 - управляется PS2 клавиатурой, бит ^2 интвертируем 
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3 фиксирует данные линии)
	call PS2_WAIT_KBD	; Ожидаем очередной CLOCK
	ld a,3			; Отправляем STOP-bit ("1") по очередному такту от клавиатуры
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3 фиксирует данные линии)
	ld a,0ah
	ld (PS2_COUNTER),a	; (Устанавливаем COUNTER = 10, чтобы бит завершения передачи обрабатывался как завершающий)
	ei			; Разрешим прерывания после отправки всех данных
	ret			; Выйти из процедуры отправки данных в клавиатуру без ожидания подтверждения

PS2_WAIT_KBD:
	ei			; Разрешим прерывания и ожидаем их
	halt			; Ждём прерывания (0 на CLOCK от клавиатуры)
	ld a,(PS2_RAWDATA)	; Загружаем данные о состоянии линий DATA и CLOCK на момент прерывания
	bit 2,a			; Прерывание было вызвано CLOCK от PS/2 ?
	jr nz,PS2_WAIT_KBD	; Ожидаем CLOCK=0 от PS/2 клавиатуры
	di			; Запретим прерывания для предотвращения изменений в порту клавиатуры
	ret
