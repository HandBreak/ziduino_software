; *=============================================================================*
; *	Модуль монитора								*
; *	Осуществляет просмотр и редактирование содержимого RAM, запуск кода 	*
; *	Сам модуль размещается в ROM						*
; *  !!! ВВИДУ ИСПОЛЬЗОВАНИЯ В МОДУЛЕ КОНВЕРТАЦИИ BIN2HEX ФУНКЦИИ RLD НАД   !!! *
; *  !!! ИСХОДНЫМИ ДАННЫМИ, ПРОСМОТР КОДА BIOS ИЛИ САМОГО МОНИТОРА МОЖЕТ    !!! *
; *  !!! ПРИВОДИТЬ К НЕПРЕДСКАЗУЕМЫМ ПОСЛЕДСТВИЯМ В РАБОТЕ МОНИТОРА             *
; *=============================================================================*
;
	org	02fe5h 	;(3000 - 27 байт заголовка)
;       ================================================= Заголовок ==========================================
;	     преамбула     | Назв.16 байт     |конц|Смещение |Page|Адр.размщ|Длн.блока|КОДXXXXXX|маркер нач...
	defb 0x55,0xAA,0xAA,"System Monitor  ",0x00,0x00,0x00,0x00,0x00,0x30,0x85,0x0a
;	======================================================================================================
;	- Смещение: 	Указывается 00, если код идёт сразу после заголовка (при запуске из ROM), либо абсолютный адрес, если запуск
;         		осуществляется из EEPROM (при этом предварительно все заголовки копируются в буфер)
;	- Page:		Номер страницы RAM в которую должен быть загружен код. По-умолчаниюю 00h (возможно 40h,80h,c0h,00h)
;	- Адрес размещ: Адрес с которого должен быть размещён и запущен указанный код. По-умолчанию c000h
;	- Длина блока:	Размер копируемого кода. Количество байт кода, в пределах 65535
;
; ==============================
; System Monitor
; input
;	none
; output:
;	none
; ------------------------------
SM_INIT:
	call SM_SAVEREGS	; Сохраним состояние всех регистров и стека
	call CLEAR_SCREEN	; Выполнить очистку экрана
	call SM_PRNSETPOS00	; Установить позицию и атрибуты XY=0,0
	ld h,(ix+prn_y)		; Загрузить X-координату и атрибуты печати
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	ld l,a			; В HL позиция вывода XY=0,0 с текущими атрибутами вывода
	ld de,SM_MSGHLL		; Адрес приветственного сообщения
	call PRN_STRING		; Отобразить заголовок
				; Ининициализируем переменные
	ld hl,SM_VADDR
	ld (hl),0c0h		
	inc hl
	ld (hl),00h		; Установить адрес по умолчанию #C000
  SM_MAIN_LOOP:
	call SM_CMDPOSCALC	; Установить позицию командной строки
	push hl			; Сохранить координаты печати
	call CLR_STRING		; Очистить командную строку перед перерисовкой
	pop hl			; Восстановить координаты печати
	ld de,SM_MSGCMD		; Загрузить адрес строки приглашения
	call PRN_STRING		; Вывести строку приглашения.
  SM_MAIN_WAITKEY:
 	ld (ix+scan_code),00h	; Очистить буфер ввода
	halt			; Подождать прерывание
	call KEY_CURSOR		; Отобразить курсор в текущей позиции
	push hl
	call PS2CODE_CONVERT	; Проверка буфера PS/2 клавиатуры
	pop hl
	ld a,(ix+scan_code)
	or a			; В буфере код 00 ?
	jr z,SM_MAIN_WAITKEY	; Продолжаем пока нет других кодов

	push af			; Сохраним считанный код
	ld a,20h		; Загружаем код "пробела"
	call SYM_DRAW		; Вызываем отрисовку символа по в текущей (HL) позиции
	pop af			; Восстановим считанный код

	cp 1bh			; ESC ?
	ret z			; Выход если нажат ESC
	and 0dfh		; Сбросим bit5 (перевод в верхний регистр)
	cp "A"
	call z,SM_SETADDR	; Если нажата перейти к установке текущего адреса
	cp "C"
	call z,SM_CPBLK		; Вызвать копирование блока памяти
	cp "D"
	call z,SM_DUMP		; Вызвать просмотр дампа памяти
	cp "E"
	call z,SM_EDITOR	; Вызвать редактор памяти
	cp "F"
	call z,SM_FILLMEM	; Вызвать заполнение памяти
	cp "G"
	call z,SM_CALLPRG	; Передать управление программе
	cp "H"
	call z,SM_PRNHELP	; Отобразить подсказку
	cp "P"
	call z,SM_MEMPAGE	; Смена страницы памяти
	cp "R"
	call z,SM_REGS		; Отобразить/Изменить состояние регистров
	cp "Q"
	ret z			; Завершить работу монитора и вернуться в основное меню
	or a
	call nz,PS2_BUF_OVERFLOW; Воспроизвести звук ошибки, если A<>0 (ошибка выполнения подпрограммы или нет соответствующей подпрограммы)
	jr SM_MAIN_LOOP		; Если совпадения не обнаружено или произошёл возврат из выбранной функции, перерисовать строку ввода команды и перейти к ожиданию ввода
; ------------------------------
;
; ==============================
; System Monitor ADDR SET
; input
;	none
; output:
;	none
; ------------------------------
SM_SETADDR:
	call SM_CMDPROMT
	ld de,SM_MSGADR
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	; отобразить текущее значение до начала ввода и ждать любой клавиши
	ld hl,SM_VADDR		; HL адрес буфера источника
	call SM_INPCURR		; Вызвать отображение текущих и ожидание новых данных
 	ret z			; Выйти в основное меню со звуком ошибки, если ESC или сразу ENTER (без данных)
 	call SM_BUFCORR		; Коррекция содержимого буфера ввода
 	ld de,SM_VADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!	
	jr c,SM_SETADDR		; Повторный ввод из-за ошибки данных
	xor a
	ret
; ------------------------------
;
; ==============================
; System Monitor COPY BLOCK RAM
; input
;	none
; output:
;	none
; ------------------------------
SM_CPBLK:
	call SM_CMDPROMT
	ld de,SM_MSGCP1		; Адрес приглашения ввода адреса источника
	call SM_PROMPT		; Отобразить приглашение ввода
	call SM_INPUT4		; Запросить ввод адреса начала блока
	ret z			; Выйти в основное меню со звуком ошибки, если ESC
	or a
	jr z,SM_CPBLK		; Пустая строка ? - повтор ввода
	ld de,SM_SADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!	
	jr c,SM_CPBLK		; Повторный ввод из-за ошибки данных
  SM_CPBLK_DADR:
	call SM_CMDPROMT
	ld de,SM_MSGCP2		; Адрес приглашения ввода адреса приёмника
	call SM_PROMPT		; Отобразить приглашение ввода
	call SM_INPUT4		; Запросить ввод адреса конца блока
	jr z,SM_CPBLK		; Вернуться к предыдущему действию если ESC
	or a
	jr z,SM_CPBLK_DADR	; Пустая строка ? - повтор ввода
	ld de,SM_DADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_CPBLK_DADR	; Повторный ввод из-за ошибки данных
  SM_CPBLK_LENGHT:
	call SM_CMDPROMT
	ld de,SM_MSGCP3		; Адрес приглашения ввода длины блока (DEC)
	call SM_PROMPT		; Отобразить приглашение ввода
	ld (ix+input_len),05h	; Ввод 5 символов
	call SM_INPUT		; Запросить ввод размера копируемого блока
	jr z,SM_CPBLK_DADR	; Вернуться к предыдущему действию если ESC
	or a
	jr z,SM_CPBLK_LENGHT	; Пустая строка ? - повтор ввода
	call CONV_DEC2BIN	; Результат будет в паре DE
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_CPBLK_LENGHT	; Повторный ввод из-за ошибки данных
	ld hl,SM_LENGHT		; Сюда будет помещён результат преобразования
	ld (hl),e		; младший байт результата
	inc hl
	ld (hl),d		; старший байт результата
	call SM_CMDPROMT	; Очистить командную строку перед меню подтверждения
  SM_CPBLK_ACCEPT:
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	or 02h
	ld l,a
	ld h,0			; Установить позицию вывода XY=0,2
	call PRINT_SETPOS
	call CLR_UNDERSTRING	; Очистить экран начиная с данной строки
	inc (ix+prn_y)		; Вывод начинать с 3-ей строки
	ld de,SM_MSGCP4
	rst prn_wascr		; Отобразить "Source:"
	ld hl,SM_SADDR		; HL Адрес переменной с адр.начала
	ld a,4			; Число ASCII знаков
	call SM_ACPMENU		; Отобразить значение
	ld de,SM_MSGCP5
	rst prn_wascr		; Отобразить "Destin:"
	ld hl,SM_DADDR		; HL Адрес переменной с адр.конца
	ld a,4			; Число ASCII знаков
	call SM_ACPMENU		; Отобразить значение
	ld de,SM_MSGCP6
	rst prn_wascr		; Отобразить "Lenght:"
	ld hl,SM_LENGHT		; HL Адрес переменной с размером блока
	ld e,(hl)
	inc hl
	ld d,(hl)		; DE Преобразуемое двоичное число
	ld hl,SM_PRNBUFF	; HL Адрес буфера в который сохранить ASCII результат
	call CONV_BIN2DEC	; Преобразровать, DE=адрес начала ASCII буфера
	ex de,hl		; DE<-адрес буфера
	rst prn_wascr		; Отобразить значение
	inc (ix+prn_y)		; Перейти на строку ниже
	ld de,SM_MSGCP7
	rst prn_wascr		; Отобразить "Accept?"
	call SM_WAIT_AKEY
	cp "y"			; Проверить нажатие "Yes"
	call z,SM_COPYGO	; Перейти к копированию блока
	jr nz,SM_CPBLK_CANCEL	; Сообщить об ошибке / отмене копирования и выйти
	ld de,SM_MSGCP8
	rst prn_wascr		; Отобразить поверх Accept-а "Success"
	xor a
	ret
  SM_CPBLK_CANCEL:
	push af
	ld de,SM_MSGCP9
	rst prn_wascr		; Отобразить поверх Accept-а "Success"
	pop af
	ret			; Выйти в основное меню с сигналом ошибки, если не подтверждено или возникла ?ошибка заполнения? 
; ------------------------------
  SM_COPYGO:
	ld hl,SM_SADDR		; Адрес переменных
	call SM_LDDATA		; Загрузить переменные в регистры  DE=Адрес источника, BC=Адрес приёмника
	inc hl
	ex de,hl		; DE=Адрес переменной размера блока, HL<-Адрес источника |BC=Адрес приёмника
	or a			; Сбросить CY
	push hl			; Сохранить адрес источника
	sbc hl,bc		; A.Источника > A.Приёмника ?
	ex de,hl		; HL=адрес переменной размера блока
	ld d,b
	ld e,c			; DE=Адрес приёмника
	ld c,(hl)
	inc hl
	ld b,(hl)		; BC=Длина блока
	pop hl			; HL=Адрес источника
	jr nc,SM_COPY_HTL	; Если адрес источника HL => адреса приёмника BC, использовать LDIR, иначе
	add hl,bc		; HL=Адрес последнего байта блока источника
	ex de,hl
	add hl,bc
	ex de,hl		; DE=Адрес последнего байта блока приёмника
	dec hl
	dec de			; Скорректировать адрес конечной позиции
	lddr			; Копировать блок
	xor a			; Признак "завершено успешно"
	ret			; Завершиьть процедуру
  SM_COPY_HTL:
	ldir			; Копировать блок
	xor a			; Признак "завершено успешно"
	ret			; завершить процедуру
; ------------------------------
;
; ==============================
; System Monitor DUMP MEMORY
; input
;	none
; output:
;	none
; ------------------------------
SM_DUMP:
	ld hl,(SM_VADDR)
	ld (SM_CADDR),hl	; Копируем текущий адрес в текущий адрес редактора	
	call SM_CMDPROMT
	ld de,SM_MSGDM1		; Адрес приглашения ввода адреса печати дампа памяти
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	; отобразить текущее значение до начала ввода и ждать любой клавиши
	ld hl,SM_CADDR		; HL адрес буфера источника
	call SM_INPCURR		; Вызвать отображение текущих и ожидание новых данных
	cp 1bh			; Нажат ESC ?
	ret z			; Выйти в основное меню со звуком ошибки, если ESC, иначе:
	or a			; Нажата ENTER ?
	jr z,SM_DPMAIN		; Если да, использовать адрес по-умолчанию. Иначе
	call SM_BUFCORR	
	ld de,SM_CADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_DUMP		; Повторный ввод из-за ошибки данных	
  SM_DPMAIN:
	call CLEAR_SCREEN	; Выполнить очистку экрана
  SM_DPMAINLP1:
	ld hl,SM_CADDR		; Выбираем переменную текущего адреса
	ld d,(hl)
	inc hl
	ld e,(hl)		; DE=текущий адрес
  SM_DPMAINLP2:
	push de
	call SM_PRNSETPOS00	; Установить позицию и атрибуты
	call SM_DPPRN		; Вызвать вывод дампа памяти
	call SM_WAIT_AKEY	; Ждём действий пользователя
	pop de
	ld hl,0004		; Следующий/предыдущий адрес
	cp 1bh
	ret z			; Выйти в основное меню, если нажат ESC
	cp 18h			; Если нажата стрелка вверх
	jr nz,SM_DPUPSKP	; Если нажата, уменьшить адрес на 1 и повтор вывода
	ex de,hl
	or a
	sbc hl,de
	ex de,hl		; Уменьшить адрес на 4
	jr SM_DPMAINLP2		; Вывести список с уменьшенным на 1 значением адреса
  SM_DPUPSKP:
	cp 0bh			; Если нажата стрелка вниз
	jr nz,SM_DPDOWNSKP	; Если нажата, увеличить адрес на 1 и повтор ввода
	ex de,hl
	add hl,de
	ex de,hl		; Увеличить адрес на 4
	jr SM_DPMAINLP2		; Вывести список с увеличенным на 1 значением адреса
  SM_DPDOWNSKP:	
	cp 20h			; Пробел ?  - 
	jr z,SM_DPMAINLP1	; Если да, листаем на страницу вниз
	jr SM_DPMAINLP2		; Во всех остальных случаях
; ------------------------------	
  SM_DPPRN:
	ld b,7			; Счетчик числа выводимых строк	
  SM_DPPRNLOOP:	
	ld hl,SM_CADDR+1	; Выбираем переменную текущего адреса (со старшего адреса - младшего байта данных)
	ld (hl),e
	dec hl
	ld (hl),d		; Сохраним текущий адрес верхней строки дапма
	push bc			; Сохранить счетчик строк
	push de			; Сохранить адрес текущего байта
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,4			; Число ASCII знаков
	push de			; Сохранить адрес начала буфера
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	rst prn_wascr		; Отобразить адрес в текущей строке
	pop hl			; HL=текущий адрес памяти для вывода содержимого	
	ld b,4			; количество отображаемых байт в строке
  SM_DPPRSTLOOP:
	inc (ix+prn_x)		; Пропустить одно знакоместо
	push bc			; Сохранить счетчик столбцов
	push hl			; Сохранить адрес памяти
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,2			; Число ASCII знаков
	push de
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	rst prn_wascr		; Отобразить байт данных в текущей строке
	pop hl			; Восстановить адрес памяти
	inc hl			; увеличить адрес на 1
	pop bc			; восстановить счетчк
	djnz SM_DPPRSTLOOP	; Повторить цикл вывода строки дампа
	ld (ix+prn_x),00h	; На её начало
	pop bc			; Восстановить счтетчик строк
	ex de,hl		; Следующий адрес поместить в DE
	djnz SM_DPPRNLOOP	; Повторить в цикле 7 раз, до заполнения экрана
	ld de,SM_MSGDM2		; Строка со списком доступных команд
	rst prn_wascr		; Отобразить
	ret			; Завершить цикл печати страницы дампа
; ------------------------------
;
; ==============================
; System Monitor MEMORY EDITOR
; input
;	none
; output:
;	none
; ------------------------------
SM_EDITOR:
	ld hl,(SM_VADDR)
	ld (SM_CADDR),hl	; Копируем текущий адрес в текущий адрес редактора	
	call SM_CMDPROMT
	ld de,SM_MSGED1		; Адрес приглашения ввода адреса редактирования
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	; отобразить текущее значение до начала ввода и ждать любой клавиши
	ld hl,SM_CADDR		; HL адрес буфера источника
	call SM_INPCURR		; Вызвать отображение текущих и ожидание новых данных
	cp 1bh			; Нажат ESC ?
	ret z			; Выйти в основное меню со звуком ошибки, если ESC, иначе:
	or a			; Нажата ENTER ?
	jr z,SM_EDMAIN		; Если да, использовать адрес по-умолчанию. Иначе 
	call SM_BUFCORR	
	ld de,SM_CADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_EDITOR		; Повторный ввод из-за ошибки данных	
  SM_EDMAIN:
	call CLEAR_SCREEN	; Выполнить очистку экрана
	ld hl,SM_CADDR		; Выбираем переменную текущего адреса
	ld d,(hl)
	inc hl
	ld e,(hl)		; DE=текущий адрес
	dec de
	dec de
	dec de
  SM_EDMAINLP:
	call SM_PRNSETPOS00	; Установить позицию и атрибуты
	push de			; Сохранить текущий адрес
	call SM_EDPRN		; Вызвать отрисовку содержимого памяти
	call SM_WAIT_AKEY	; Ждём действий пользователя
	pop de			; восстановить текущий адрес
	cp 1bh
	ret z			; Выйти в основное меню, если нажат ESC
	cp 18h			; Если нажата стрелка вверх
	jr nz,SM_EDUPSKP	; Если нажата, уменьшить адрес на 1 и повтор вывода
	dec de
	jr SM_EDMAINLP		; Вывести список с уменьшенным на 1 значением адреса
  SM_EDUPSKP:
	cp 0bh			; Если нажата стрелка вниз
	jr nz,SM_EDDOWNSKP	; Если нажата, увеличить адрес на 1 и повтор ввода
	inc de
	jr SM_EDMAINLP		; Вывести список с увеличенным на 1 значением адреса
  SM_EDDOWNSKP:
	push de
	call SM_EDCHKINP
	pop de
	jr c,SM_EDMAINLP	; Вывести список как есть, если данные не вводились
	jr z,SM_EDMAINLP	; Вывести список как есть, если данные вводились c ошибкой или ввод отменён
	inc de			; Увеличить адрес на 1, если данные введены успешно
	jr SM_EDMAINLP		; Вывести список как есть
; ------------------------------
  SM_EDCHKINP:
	cp 67h			; Меньше 'g' ?
	ccf
	ret c			; Выход с CY, если >'f'
	cp 30h			
	ret c			; Выход с CY, если <'0'
	cp 3ah
	jr c,SM_EDINP		; Если ,<='9',но >'0' - перейти к непосредственному вводу
	cp 41h
	ret c			; Выход с CY, если <'A'
	cp 47h
	jr c,SM_EDINP		; Если <='G', но =>'A' - перейти к непосредственному преобразованию
	cp 61h
	ret c			; Если <'a', выйти с CY=1, иначе (61-67), продолжить обработку
  SM_EDINP:			; Ввод новых данных
  	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	or 03h
	ld l,a
	ld h,6			; Установить позицию вывода XY=6,3
	push de			; Сохранить текущий адрес
	call PRINT_SETPOS
	ld (ix+input_len),02h	; Ввод двух символов
	call SM_INPUT		; Запросить ввод адреса конца блока
	pop de			; Восстановить текущий адрес
	ret z			; Выход если ESC
	or a
	ret z			; Выход если пустая строка
	ex de,hl		; DE = Адрес буфера с введёнными данными
	ld bc,3
	add hl,bc		; HL = ADDR
	ld c,(hl)		; Сохраним текущее содержимое ячейки на случай ошибки ввода
	ex de,hl		; DE = ADDR, HL = Buffer
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr nc,SM_EDSCSS		; Успешное завершение ввода данных
	ld (hl),c		; Восстановить содержимое ячейки
	ret			; Повторный ввод из-за ошибки данных
  SM_EDSCSS:
	or 0ffh			; Выход после успешного ввода
	ret	
; ------------------------------
  SM_EDPRN:
	ld b,7			; Счетчик числа выводимых строк	
  SM_EDPRNLOOP:	
	ld hl,SM_CADDR+1	; Выбираем переменную текущего адреса (со старшего адреса - младшего байта данных)
	ld (hl),e
	dec hl
	ld (hl),d		; Вывод начинаем с адреса на 3 меньше установленного
	push bc			; Сохранить счетчик строк
	push de			; Сохранить адрес текущего байта
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,4			; Число ASCII знаков
	push de			; Сохранить адрес начала буфера
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	rst prn_wascr		; Отобразить адрес в текущей строке
	pop hl			;
	pop af
	push af			; A=номер текущей строки
	push hl			; (HL)=Текущий адрес памяти 	
	inc (ix+prn_x)
	cp 04h			; Редактируемая строка ?
	push af			; Сохранить результат проверки
	jr nz,SM_EDPRNSKP1	; Если нет, пропустить печать указателя позиции
	ld a,">"
	push hl
	ld l,(ix+prn_y)		;
	ld h,(ix+prn_x)		; HL=текущая позиция + атрибуты	
	call SYM_DRAW
	pop hl
  SM_EDPRNSKP1:
	inc (ix+prn_x)		; Отступ в 2 пробела
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,2			; Число ASCII знаков
	push de
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	rst prn_wascr		; Отобразить байт данных в текущей строке
	pop af			; Восстановить результат проверки
	jr nz,SM_EDPRNSKP2	; Если нет, пропустить печать указателя позиции
	ld a,"<"
	ld l,(ix+prn_y)		;
	ld h,(ix+prn_x)		; HL=текущая позиция + атрибуты	
	call SYM_DRAW
  SM_EDPRNSKP2:
	inc (ix+prn_y)		; Опуститься на строку ниже
	ld (ix+prn_x),00h	; На её начало
	pop de
	pop bc
	inc de
	djnz SM_EDPRNLOOP	; Выводим строки в цикле, пока B<>0
	ld de,SM_MSGED2		; Строка со списком доступных команд
	rst prn_wascr		; Отобразить
	ret			; Возврат в основной цикл ожидания ввода
; ------------------------------
;
; ==============================
; System Monitor FILL MEMORY
; input
;	none
; output:
;	none
; ------------------------------
SM_FILLMEM:
	call SM_CMDPROMT
	ld de,SM_MSGFL1		; Адрес приглашения ввода стартового адреса
	call SM_PROMPT		; Отобразить приглашение ввода
	call SM_INPUT4		; Запросить ввод адреса начала блока
	ret z			; Выйти в основное меню со звуком ошибки, если ESC
	or a
	jr z,SM_FILLMEM		; Пустая строка ? - повтор ввода
	ld de,SM_SADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_FILLMEM		; Повторный ввод из-за ошибки данных
  SM_FILLMEM_EADR:
	call SM_CMDPROMT
	ld de,SM_MSGFL2		; Адрес приглашения ввода конечного адреса
	call SM_PROMPT		; Отобразить приглашение ввода
	call SM_INPUT4		; Запросить ввод адреса конца блока
	jr z,SM_FILLMEM		; Вернуться к предыдущему действию если ESC
	or a
	jr z,SM_FILLMEM_EADR	; Пустая строка ? - повтор ввода
	ld de,SM_EADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_FILLMEM_EADR	; Повторный ввод из-за ошибки данных
	call SM_FMCHKDT		; Вызвать проверку допустимости указанных данных
	jr nc,SM_FILLMEM	; Повторный ввод Start + End 
  SM_FILLMEM_BYTE:
	call SM_CMDPROMT
	ld de,SM_MSGFL3		; Адрес приглашения ввода байта заполнения
	call SM_PROMPT		; Отобразить приглашение ввода
	ld (ix+input_len),02h	; Ввод двух символов
	call SM_INPUT		; Запросить ввод адреса конца блока
	jr z,SM_FILLMEM_EADR	; Вернуться к предыдущему действию если ESC
	or a
	jr z,SM_FILLMEM_BYTE	; Пустая строка ? - повтор ввода
	ld de,SM_FBYTE		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!		
	jr c,SM_FILLMEM_BYTE	; Повторный ввод из-за ошибки данных
	call SM_CMDPROMT	; Очистить командную строку перед меню подтверждения
  SM_FILLMEM_ACCEPT:
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	or 02h
	ld l,a
	ld h,0			; Установить позицию вывода XY=0,2
	call PRINT_SETPOS
	call CLR_UNDERSTRING	; Очистить экран начиная с данной строки
	inc (ix+prn_y)		; Вывод начинать с 3-ей строки
	ld de,SM_MSGFL4
	rst prn_wascr		; Отобразить "First:"
	ld hl,SM_SADDR		; HL Адрес переменной со адр.начала
	ld a,4			; Число ASCII знаков
	call SM_ACPMENU		; Отобразить значение
	ld de,SM_MSGFL5
	rst prn_wascr		; Отобразить "Last:"
	ld hl,SM_EADDR		; HL Адрес переменной со адр.конца
	ld a,4			; Число ASCII знаков
	call SM_ACPMENU		; Отобразить значение	
	ld de,SM_MSGFL6
	rst prn_wascr		; Отобразить "Byte:"
	ld hl,SM_FBYTE		; HL Адрес переменной со байтом заполнения
	ld a,2			; Число ASCII знаков
	call SM_ACPMENU		; Отобразить значение
	ld de,SM_MSGFL7
	rst prn_wascr		; Отобразить "Accept?"
	call SM_WAIT_AKEY
	cp "y"			; Проверить нажатие "Yes"
	call z,SM_FILLGO	; Перейти к заполнению и выйти
	jr nz,SM_FILLMEM_CANCEL	; Ошибка / отмена заполнения
	ld de,SM_MSGFL8
	rst prn_wascr		; Отобразить поверх Accept-а "Success"
	xor a			; Выйти без ошибки
	ret
  SM_FILLMEM_CANCEL:
	push af
	ld de,SM_MSGFL10
	rst prn_wascr		; Отобразить поверх Accept-а "Cancelled"
	pop af
	ret			; Выйти в основное меню с сигналом ошибки, если не подтверждено или возникла ?ошибка заполнения? 
;
; ------------------------------
  SM_FMCHKDT:
	ld hl,SM_SADDR		; Адрес переменных
	call SM_LDDATA		; DE = Начало, BC = Конец
	ld h,d
	ld l,e			; HL = начало
	sbc hl,bc		; BC>HL ?  Если, нет - ошибка
	ret c			; Проверка прошла успешно, если возник перенос (КОНЕЦ>НАЧАЛА)
	ld de,SM_MSGFL9		; Сообщение о некорректном значении адреса
	rst prn_wascr		; Отобразить сообщение об ошибке
	jp SM_WAIT_AKEY		; Ждём любую клавишу и возвращаемся из ожидания с флагом NC (or a перед выходом из цикла)

; ------------------------------
  SM_FILLGO:
	ld hl,SM_SADDR		; Адрес переменных
	call SM_LDDATA
	inc hl
	ld a,(hl)		; A=Байт заполнения
	ld h,b
	ld l,c			; HL=Адрес конца блока
	or a			; Сбросить CY
	sbc hl,de		; HL=длина блока
	ld b,h
	ld c,l			; BC=Длина блока
	push de
	pop hl			; HL=DE=Начало блока
	inc de			; DE=HL+1
	ld (hl),a		; HL-начало
	ldir			; DE-начало+1, BC-длина, A-байт заливки
	xor a			; Выход без ошибки
	ret
; ------------------------------
;
; ==============================
; System Monitor CALL PROGRAM
; input
;	none
; output:
;	none
; ------------------------------
SM_CALLPRG:
	ld hl,(SM_VADDR)
	ld (SM_CADDR),hl	; Копируем текущий адрес в текущий адрес перехода	
	call SM_CMDPROMT
	ld de,SM_MSGGO1		; Адрес приглашения ввода адреса вызыва программы
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	; отобразить текущее значение до начала ввода и ждать любой клавиши
	ld hl,SM_CADDR		; HL адрес буфера источника
	call SM_INPCURR		; Вызвать отображение текущих и ожидание новых данных
	cp 1bh			; Нажат ESC ?
	ret z			; Выйти в основное меню со звуком ошибки, если ESC, иначе:
	or a			; Нажата ENTER ?
	jr z,SM_GO		; Если да, использовать адрес по-умолчанию. Иначе 
	call SM_BUFCORR		; Коррекция содержимого буфера ввода	
	ld de,SM_CADDR		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!
	jr c,SM_CALLPRG		; Повторный ввод из-за ошибки данных
  SM_GO:
	ld de,(SM_CADDR)	; Считать адрес вызова программы
	ld hl,SM_GObADR+1	; Ячейки с адресом вызова
	ld (hl),d
	inc hl
	ld (hl),e		; Установить адрес вызова (с учетом обратного порядка в DE)

	ld (SM_RG_SPc),sp	; Сохранить указатель стека перед запуском (указывает на адрес возврата	
	ld a,(SM_RG_I)
	ld i,a
	ld hl,(SM_RG_AF)
	push hl
	pop af
	ex af,af'
	ld hl,(SM_RG_AFa)
	push hl
	pop af
	ex af,af'
	ld sp,(SM_RG_SP)
	ld hl,(SM_RG_HL)
	ld bc,(SM_RG_BC)
	ld de,(SM_RG_DE)
	exx
	ld hl,(SM_RG_HLa)
	ld bc,(SM_RG_BCa)
	ld de,(SM_RG_DEa)
	ld ix,(SM_RG_IX)
	ld iy,(SM_RG_IY)
	exx

  SM_GObADR:			; Адрес SMGObADR+1 для патчинга адреса вызова программы
	call SM_GOADDRESS	; Вызвать заданную подпрограмму (SM_GOADDRESS патчится)
  SM_GOADDRESS:			; По-умолчанию подставляется адрес возврата 
	jp SM_SAVEREGS1		; Сохраняем все регистры по результатам исполнения кода и возвращаемся в основное меню
; ------------------------------
;
; ==============================
; System Monitor PRINT HELP
; input
;	none
; output:
;	none
; ------------------------------
SM_PRNHELP:
	call SM_PRNSETPOS00
	ld de,SM_MSGHELP1	; Начала строк подсказки
  SM_PRNNXLN:
	rst prn_scr		; Вывести строку с прокруткой
	inc de			; Перейти к началу следующей строки
	ld a,(ix+prn_y)		; Запросить текущую строку
	and 07h			; Без атрибутов
	cp 07h			; Если конец экрана не достигнут
	jr c,SM_PRNNXLN		; Отобразить следующую строку
	push de			; Сохранить адрес следующей строки вывода
	ld de,SM_MSGPRENT	; Сообщение "ENTER для продолжения
	call SM_CMDPOSCALC	; Установить позицию командной строки
	call PRN_STRING		; Отобразить снизу строку, не меняя текущую позицию
	call SM_WAIT_AKEY	; Ждём ENTER
	pop de			; восстановить адрес следующей строки вывода
	cp 1bh			; Нажат 'ESC' ?
	ret z			; Выйти в основное меню, если нажат со звуком ошибки
	ld a,(de)
	or a			; Если следующая строка начинается с 00h, справка закончилась
	jr nz,SM_PRNNXLN
	ret
; ------------------------------
;
; ==============================
; System Monitor MEMORY PAGE
;		 SELECT
; input
;	none
; output:
;	none
; ------------------------------
SM_MEMPAGE:
	call SM_CMDPROMT
	ld de,SM_MSGPGM
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	ld a,(ix+port_mode)	; Запросить текущую конфигурацию системного порта
	and 0c0h		; Оставим только биты управления памятью
	rlca			;
	rlca			; Разделим на 64 (переместим в bit0 и bit1)
	ld hl,SM_MPAGE
	ld (hl),a		; Сохраним в переменную номер страницы 0-3
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,1			; Число ASCII знаков
	push de			; Сохранить адрес начала буфера
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	ld l,(ix+prn_y)		; Установить позицию
	ld h,(ix+prn_x)		; И режим ввода
	call PRN_STRING		; Вывести текущее значение буфера без изменения координат ввода
	call SM_WAIT_AKEY	; Ожидаем начала ввода
	call CLR_ENDSTRING	; Очистить конец строки
	ld (ix+input_len),01h	; Ввод четырёх символов
	call SM_INPBUFF		; Вызвать ввод строки
	ret z			; Выйти в основное меню со звуком ошибки, если ESC или сразу ENTER (без данных)
	ld de,SM_MPAGE		; Сюда будет помещён результат преобразования
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	jr c,SM_MEMPAGE		; Повторный ввод из-за ошибки данных
	ld a,(SM_MPAGE)		; Прочитать установленную конфигурацию памяти
	cp 04h			; Номер страницы (0-3)
	jr nc,SM_MEMPAGE
	rrca
	rrca			; Уножить на 64 (переместим в bit7 и bit6)
	call MEM_CONFIG		; Активировать выбранную страницу
	xor a
	ret
; ------------------------------
;	
; ==============================
; System Monitor PRINT REGISTERS
; input
;	none
; output:
;	none
; ------------------------------
SM_REGS:
	ld hl,SM_MSGRV1		; Адрес начала текстового вывода
	push hl			; Сохранить для дальнейшей печати
	call SM_PREPPRN		; Подготовить к печати ASCII форму состояния регистров
	call SM_PRNSETPOS00	; Позиция вывода XY=0,0
	pop de			; Восстановить адрес текста с состоянием регистров
	rst prn_wascr		; Отобразить регистры
	ld de,SM_MSGRG1		; Строка запроса изменения регистров
	rst prn_wascr		; Вывести запрос
	call SM_WAIT_AKEY	; Ждём 'y' или любую клавишу
	cp "y"			; Проверить нажатие "Yes"
	call z,SM_REGED		; Перейти к редактированию состояния регистров
	ret
; ------------------------------
SM_REGED:
	ld b,1
  SM_REGEDML1:
	push bc			; сохранить временно счетчик	
	call SM_PRNSETPOS00	; Установить позицию и атрибуты
	ld hl,SM_MSGRV1		; Адрес начала текстового вывода
	push hl			; Сохранить для дальнейшей печати
	call SM_PREPPRN		; Подготовить к печати ASCII форму состояния регистров	
	pop de
	rst prn_wascr		; Отобразить регистры
	call SM_CMDPROMT	; Далее вывод в зоне командной строки
	ld de,SM_MSGRG2
	rst prn_wascr		; Отобразить приглашение ввода
	pop bc

	push bc			; Восстановить номер позиции в B
	call SM_REGEDCURPR	; Отобразить курсор в соответствующей позиции
	call SM_WAIT_AKEY	; Ждём действий пользователя
	pop bc
	cp 1bh
	jr nz,SM_REGEDML3	; Если нажат ESC, отобразить состояние и выйти в основное меню
	push af			; Сохранить флаги и код выхода
	call SM_PRNSETPOS00	; Позиция вывода XY=0,0
	ld de,SM_MSGRV1		; Адрес начала текстового вывода
	rst prn_wascr		; Отобразить регистры
	pop af			; Восстановить флаги и код выхода со звуковым сигналом
	ret
; ------------------------------	
  SM_REGEDML3:
	push bc
	call SM_REGINP
	pop bc	
	cp 18h			; Если нажата стрелка вверх
	jr nz,SM_REGEDML2	; Если нажата, уменьшить адрес на 2 и повтор вывода
	dec b
	ld a,b
	or a
	jr nz,SM_REGEDML1	; Отобразить предыдущую позицию, если не дошли до '0'
	ld b,0dh		; Перейти к последней позиции (SP)
	jr SM_REGEDML1
  SM_REGEDML2:
	cp 0bh			; Если нажата стрелка вниз
	jr nz,SM_REGEDML1	; Если нажата, увеличить адрес на 1 и повтор ввода
	inc b			; Увеличить номер позициии  на 2
	ld a,b
	cp 0eh			; Если превышен конец списка, вернуться к 1-ой позиции
	jr c,SM_REGEDML1	; Пока не достигнуто 14, иначе:
	ld b,01h
	jr SM_REGEDML1		; Перерисовать меню
; ------------------------------
  SM_REGINP:
	cp 67h			; Меньше 'g' ?
	ccf
	ret c			; Выход с CY, если >'f'
	cp 30h			
	ret c			; Выход с CY, если <'0'
	cp 3ah
	jr c,SM_REGINP1		; Если ,<='9',но >'0' - перейти к непосредственному вводу
	cp 41h
	ret c			; Выход с CY, если <'A'
	cp 47h
	jr c,SM_REGINP1		; Если <='G', но =>'A' - перейти к непосредственному преобразованию
	cp 61h
	ret c			; Если <'a', выйти с CY=1, иначе (61-67), продолжить обработку
  SM_REGINP1:
	ld a,b			; A=номер позиции
	ld (SM_CADDR),a
  SM_REGINP4:
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	or 07h
	ld l,a
	ld h,2			; Установить позицию вывода XY=2,7
	call PRINT_SETPOS	; Установить позицию и атрибуты
	call CLR_ENDSTRING	; Очистить строку начиная с установленной позиции
	ld de,SM_MSGRG3		; Подстановка 0x к началу вводимых данных
	rst prn_wascr		;
	ld a,(SM_CADDR)
	cp 0ah
	jr z,SM_REGINP2		; Если 10-ая
	cp 0ch
	jr z,SM_REGINP2		; Или 12-ая позиция - ввод 2х символов вместо четырёх
	call SM_INPUT4		; Запросить ввод значения регистра
  SM_REGINP3:	
	ret z			; Выйти в основное меню со звуком ошибки, если ESC
	or a
	ret z			; Если пустая строка выйти в цикл опроса клавиатуры
	ld de,SM_RGINP		; Сюда будет помещён результат преобразования.  Затем требуется перенос в обратном порядке в соответствующий регистр
	push de
	call CONV_HEXTOBIN	; По указанному адресу будет сохранен результат
	call c,SM_ERRBEEP	; Воспроизвести сигнал ошибки без изменения флагов и регистров!
	pop de
	jr c,SM_REGINP4		; Повторный ввод из-за ошибки данных
	ld a,(SM_CADDR)
	dec a			; Перая позиция имеет коэффициент=0
	sla a			; A*2
	ld c,a
	ld b,0			; BC=Номер позиции x2 (при A<128)
	ld hl,SM_RG_AF		; Адрес начала массива переменных хранения регистров	
	add hl,bc		; HL=Адрес переменной выбранного регистра
	cp 18			; Это 10-ая позиция ?  (IX)
	jr z,SM_REGINP5		; Если да, копировать единственный байт в полученный адрес
	cp 20			; Это 11-ая позиция ?  (IY)
	jr z,SM_REGINP6		; Если да, корректировать адрес (-1 байт)
	cp 22			; 
	ret z			; Ничего не копировать - для регистра регенерации не имеет смысла
	cp 24			; Это 13-ая позиция ?  (SP)
	jr z,SM_REGINP7		; Если да корректировать адрес (-2 байа)
	inc hl
  SM_REGINP6:
	ld a,(de)		; Копируем старший байт
	ld (hl),a
	dec hl
	inc de
  SM_REGINP5:
	ld a,(de)		; Копируем младший байт
	ld (hl),a		; Скопировать в обратном порядке из (DE)->(HL)
	ret
; ------------------------------	
  SM_REGINP7:
	dec hl			; Корректировать адрес (-2 байта)
	dec hl
	jr SM_REGINP6
; ------------------------------
  SM_REGINP2:
	ld (ix+input_len),02h	; Ввод двух символов
	call SM_INPUT
	jr SM_REGINP3
; ------------------------------
  SM_REGEDCURPR:
	ld hl,SM_MSGRV1		; Адрес начала текстового вывода
	push hl			; сохранить адрес начала для дальнейшего вычисления смещения
	ld c,b			; Сохранить номер позиции для выбора длины строки
  SM_REGEDFNPOS:
	call SM_PREPRGVW	; Ищем первую/следующую запись
	djnz SM_REGEDFNPOS	; Ищем позицую в соответствии с указанным в B номером
	pop de			; Восстановить адрес начальной позиции
	dec hl
	dec hl			; Захватить '0x'
	push hl			; Сохранить адрес найденной позиции
	or a			; сбросить CY
	sbc hl,de		; HL=номер символа в строке (max 128)
	ld a,l
	and 0fh			; Ограничим диапазоном 0-15 (позиция в строке)
	ld h,a			; Запишем в регистр позиции по X
	srl l			; /2
	srl l			; /4
	srl l			; /8
	srl l			; L/16 = позиция по Y
	pop de			; Восстановить адрес найденной позиции
	ld b,6			; Выделять 6-ть символов
	ld a,c
	cp 0ah			; Для десятой позиции укоротить курсор до 4-х символов
	jr z,SM_REGEDFNSKP
	cp 0ch			; Для 12-ой позиции укоротить курсор до 4-х симоволов
	jr nz,SM_REGEDFNPOSL1
  SM_REGEDFNSKP:
	ld b,4			; выделять 4-е символа
  SM_REGEDFNPOSL1:
	push bc			; Сохранить счетчик символов
	push de			; Сохранить адрес символа
	push hl			; Сохранить позицию
	ld a,(ix+prn_y)
	and 0f0h		; Извлечём атрибуты печати
	or l			; Сложим с номером строки
	xor 80h			; Инвертируем цвет
	ld l,a			; Сохраним результат
	ld a,(de)		; Считать символ
	call SYM_DRAW		; Отобразить символ (A) в позиции и с атрибутами 'HL'
	pop hl			; Восстановить позицию
	pop de			; Восстановить адрес символа
	pop bc
	inc h			; Перейти к следующей позиции по X
	inc de			; Выбрать следующий символ
	djnz SM_REGEDFNPOSL1	; Отпечатать 'B' символов
	ret
; ------------------------------
  SM_PREPPRN:
	call SM_PREPRGVW	; HL указатель первой записи (AF)
	ld bc,SM_RG_AF		; Адрес начала области переменных регистров
	ld a,9			; Количество считываемых 2-х байтных значений
  SM_PREPPRNRDLP:
	push af
	ld a,(bc)
	ld e,a
	inc bc
	ld a,(bc)
	ld d,a
	inc bc
	call SM_PREPPRN4	; Последовательно читаем состояние регистров AF-IX
	pop af
	dec a
	jr nz,SM_PREPPRNRDLP
	ld a,(bc)
	ld d,a
	call SM_PREPPRN2	; Читаем состояние I
	ld de,(SM_RG_IY)
	call SM_PREPPRN4	; Читаем состояние IY
	ld a,r			; Получаем состояние R (всегда меняется)
	push hl			; Сохраняем адрес позиции печати
	ld hl,SM_CADDR		; Адрес переменной для преобразования
	ld (hl),a		; Сохраняем значение
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	push de			; Сохраняем адрес начала буфераё
	ld a,2			; Ковертировать 1 байт (2 символа)
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	pop hl			; Восстанавливем адрес позиции печати
	call SM_PREPCPSTR	; Разместим в ближайшую текстовую секцию по адресу HL	
	call SM_PREPRGVW	; Найдём следующее поле для печати
	ld de,(SM_RG_SP)	; Читаем состояние SP
	call SM_PREPPRN4	;
	ret
; ------------------------------
  SM_PREPRGVW:
	ld a,(hl)
	inc hl
	or a
	ret z			; Завершить, если конец текста
	cp "0"
	jr nz,SM_PREPRGVW	; Ищем 0, пока не найдено выбираем следующую ячейку
	ld a,(hl)
	inc hl
	cp "x"
	jr nz,SM_PREPRGVW	; Ищем "x" после "0", если не "x" то переходим к началу, иначе HL=адрес поля
	ret			; Выходим с Z&A="x",если нашли. HL=начало поля
; ------------------------------	
  SM_PREPSTR:
	push hl
	ld hl,SM_CADDR+1	; Адрес ячеек в которую сохраняем промежуточное значение регистра для преобразования в ASCII
	ld (hl),e
	dec hl
	ld (hl),d		; Сохраняем DE (значение регистра, которое необходимо прописать
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	push de
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	pop hl
	ret
; ------------------------------
  SM_PREPCPSTR:
	ld a,(de)		; Считать символ из буфера
	or a			; Конец данных в буфере ?
	ret z			; Выйти если нечего копировать
	ld (hl),a		; Скопировать в приёмную область
	inc de			; Следующий байт в источнике
	inc hl			; Следующий байт в приёмнике
	jr SM_PREPCPSTR		; Продолжать до конца строки
; ------------------------------
  SM_PREPPRN4:
	ld a,4			; Число ASCII знаков
	call SM_PREPSTR		; Преобразуем в ASCII
	call SM_PREPCPSTR	; Разместим в ближайшую текстовую секцию по адресу HL
	jp SM_PREPRGVW		; HL указатель следующей записи
; ------------------------------
  SM_PREPPRN2:
	ld a,2			; Число ASCII знаков
	call SM_PREPSTR		; Преобразуем в ASCII
	call SM_PREPCPSTR	; Разместим в ближайшую текстовую секцию по адресу HL
	jp SM_PREPRGVW		; HL указатель следующей записи	
; ------------------------------
;
; ==============================
; System Monitor WAIT_ENTER_KEY
; input
;	none
; output:
;	none
; ------------------------------
SM_WAIT_AKEY:
	ld (ix+scan_code),00h	; Очистим буфер ввода
	halt			; Ждём прерывания
	call PS2CODE_CONVERT	; Проверка буфера PS/2 клавиатуры
	ld a,(ix+scan_code)
	or a			; В буфере код 00 ?
	jr z,SM_WAIT_AKEY	; Продолжаем пока нет других кодов
	ret
; ------------------------------
;
; ==============================
; System Monitor CMDLINE_ADR
; input
;	none
; output:
;	none
; ------------------------------
SM_CMDPOSCALC:
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	or 07h			; Установить в качестве позиции вывода нижнюю строку
	ld h,0
	ld l,a			; В HL позиция вывода XY=0,7 с текущими атрибутами вывода
	ret
; ------------------------------
;
; ==============================
; System Monitor SETUP_PRINTPOS
; input
;	none
; output:
;	none
; ------------------------------
SM_PRNSETPOS00:
	ld a,(ix+prn_y)		; Загрузить строку вертикальной позиции для выделения атрибутов вывода
	and 0f0h		; Выделить только биты атрибутов печати
	ld h,0
	ld l,a			; В HL позиция вывода XY=0,0 с текущими атрибутами вывода
	jp PRINT_SETPOS		; Перейти к установки позиции
; ------------------------------
;
; ==============================
; System Monitor CMDLPROMT
; input
;	none
; output:
;	none
; ------------------------------
SM_CMDPROMT:
	ld (ix+scan_code),00h	; Очистить буфер ввода
	halt
	call SM_CMDPOSCALC	; Установить позицию командной строки
	push hl			; Сохранить координаты печати
	call CLR_STRING		; Очистить командную строку перед перерисовкой
	pop hl			; Восстановить координаты печати
	ret
; ------------------------------	
;
; ==============================
; System Monitor INPUT_TO_BUFFER
; input
;	none
; output:
;	none
; ------------------------------
SM_INPBUFF:
	ld hl,SM_INBUFF		; Установить адрес начала буфера ввода
	push hl			; Сохранить адрес начала буфера ввода
	ld (ix+input_buf_l),l
	ld (ix+input_buf_h),h	; Приёмный буфер
	ld l,(ix+prn_y)		; Установить позицию
	ld h,(ix+prn_x)		; И режим ввода
	call KEY_INPUT		; Вызвать клавиатурный ввода
	pop hl			; Отдать адрес начала буфера ввода
	ret
;
; ==============================
; System Monitor INPUT wCURR DATA
; ------------------------------	
SM_INPCURR:	
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	ld a,4			; Число ASCII знаков
	push de			; Сохранить адрес начала буфера
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	ld l,(ix+prn_y)		; Установить позицию
	ld h,(ix+prn_x)		; И режим ввода
	call PRN_STRING		; Вывести текущее значение буфера без изменения координат ввода
	call SM_WAIT_AKEY	; Ожидаем начала ввода
	call CLR_ENDSTRING	; Очистить конец строки
	; перейти непосредственно к вводу данных 
	ld (ix+input_len),04h	; Ввод четырёх символов
	call SM_INPBUFF		; Вызвать ввод строки	
	ret
; ------------------------------
;
; ==============================
; System Monitor PROMPT
; ------------------------------
SM_PROMPT:
	call PRINT_SETPOS	; Установить позицию и атрибуты для последующего ввода
	rst prn_wascr		; Отобразить командную строку
	ld l,(ix+prn_y)		; Установить позицию
	ld h,(ix+prn_x)		; И режим ввода
	call CLR_ENDSTRING	; Очистить конец строки
	ret
;
; ==============================
; System Monitor INPUT 4 SYM
; ------------------------------	
SM_INPUT4:	
	ld (ix+input_len),04h	; Ввод четырёх символов
  SM_INPUT:
	call SM_INPBUFF		; Вызвать ввод строки
	push af
	ld a,04h
	cp (ix+input_len)
	call z,SM_BUFCORR
	pop af
	cp 1bh			; Нажат ESC ?
	ret
;
; ==============================
; System Monitor ACCEPT MENU
; ------------------------------
SM_ACPMENU:
	ld de,SM_PRNBUFF	; Адрес буфера для сохранения ASCII числа
	push de
	push bc
	ld b,5			; Число очищаемых байт буфера
	ex de,hl		; Адрес буфера в HL
  SM_ACPMENU_L1:
	ld (hl),00h
	inc hl
	djnz SM_ACPMENU_L1	; Заполнить буфер 00h перед преобразованиемs
	ex de,hl		; HL вернуть в исходное состояние
	pop bc
	pop de
	push de			; Сохранить адрес начала буфера
	call CONV_BINTOHEX	; Преобразровать
	pop de			; начало буфера с ASCII-> DE
	rst prn_wascr		; Отобразить значение
	inc (ix+prn_y)		; Перейти на строку ниже
	ret
;
; ==============================
; System Monitor LOAD DATA
; ------------------------------	
SM_LDDATA:
	ld d,(hl)
	inc hl
	ld e,(hl)		; DE=Адрес начала блока
	inc hl
	ld b,(hl)
	inc hl
	ld c,(hl)		; BC=Адрес конца блока
	ret
;
; ==============================
; System Monitor LOAD DATA
; ------------------------------	
SM_ERRBEEP:
	push af
	push bc
	call PS2_BUF_OVERFLOW
	pop bc
	pop af
	ret
; ------------------------------
;
; ==============================
; System Monitor INPUT BUFFER
;		 CORRECTION
; input
;	A  - Количество символов
;	     в строке
;	HL - Адрес буфера ввода
; output:
;	HL - Адрес буфера ввода
; ------------------------------
SM_BUFCORR:
	push hl			; Адрес начала буфера данных
	push hl
	ld bc,0004h		; Требуемая длина строки
	add hl,bc
	ex de,hl		; DE= Необходимый адрес 00h 
	pop hl			; HL= Адрес начала
	ld b,00h		; Счетчик длины строки
  SM_BUFCORR_LP1:
	ld a,(hl)
	inc b	
	or a
	jr z,SM_BUFCORR_LP2
	inc hl
	jr SM_BUFCORR_LP1
  SM_BUFCORR_LP2:		; BC=Фактическая длина строки, HL=конец буфера, DE=Правильный конец буфера
	inc c
  SM_BUFCORR_LP3:
	ld (de),a
	dec hl
	dec de
	ld a,(hl)
	dec b
	jr nz,SM_BUFCORR_LP4	; Пока B=>0 копируем
	inc b			; Восстанавливаем b до 1
	ld a,"0"		; Ведущий "0" в (DE), вместо данных
  SM_BUFCORR_LP4:	
	dec c
	jr nz,SM_BUFCORR_LP3
	pop hl
	ret
; ------------------------------
;
; ==============================
; System Monitor REGISTER SAVE
;
; input
;	none
; output:
;	none
; ------------------------------
SM_SAVEREGS:
	ld (SM_RG_SPc),sp	; Сохранить указатель стека перед запуском (указывает на адрес возврата	
	
; процедура для установки безопасного смещения стека относительно его рабочего значения перед запуском пользовательской программы
;	ld (SM_RG_HL),hl	; Временное хранение HL на момент вычисления SP
;	push de
;	ld hl,0000h
;	add hl,sp
;	ld de,10h		; 16 байт двиг адреса стека для использования пользовательской программой по умолчанию
;	sbc hl,de
;	pop de
;	ld sp,hl
;	ld hl,(SM_RG_HL)	; Восстанавливаем HL для последующего его сохранения  

SM_SAVEREGS1:	
	ld (SM_RG_HL),hl
	ld (SM_RG_BC),bc
	ld (SM_RG_DE),de
	exx
	ld (SM_RG_HLa),hl
	ld (SM_RG_BCa),bc
	ld (SM_RG_DEa),de
	ld (SM_RG_IX),ix
	ld (SM_RG_IY),iy
	ld (SM_RG_SP),sp
	push hl			; Сохраним HL на будущее
	push af
	pop hl
	ld (SM_RG_AF),hl
	ex af,af'
	push af
	pop hl
	ld (SM_RG_AFa),hl
	ld a,i
	ld (SM_RG_I),a
	ld a,h
	ex af,af'
	pop hl			; Восстановим HL
	exx	
	ld sp,(SM_RG_SPc)	; Восстановить указатель стека после исполнения кода	
	xor a
  	ret
; ------------------------------
SM_MSGCMD:
	defb "Command>",00h
SM_MSGHLL:
	defb "2016 SysMon v1.0"
	defb "Press'h'for Help",00h
SM_MSGADR:
	defb "Address>0x",00h
SM_MSGCP1:
	defb "Src.Adr>0x",00h
SM_MSGCP2:
	defb "Dst.Adr>0x",00h
SM_MSGCP3:
	defb "Blk.Len>",00h
SM_MSGCP4:
	defb     "Source: 0x",00h
SM_MSGCP5:
	defb 0dh,"Destin: 0x",00h
SM_MSGCP6:
	defb 0dh,"Lenght: ",00h
SM_MSGCP7:
	defb 0dh,"Copy Block?(y)",00h
SM_MSGCP8:
	defb 0dh,"Copy complete!",00h
SM_MSGCP9:
	defb 0dh,"Copy canceled!",00h
SM_MSGED1:
	defb "Edit Adr>0x",00h
SM_MSGED2:
	defb " Up,Dwn,Ent,Esc",00h
SM_MSGDM1:
	defb "Dump Adr>0x",00h
SM_MSGDM2:
	defb " Up,Dwn,Spc,Esc",00h
SM_MSGFL1:
	defb "Str.Adr>0x",00h
SM_MSGFL2:
	defb "End.Adr>0x",00h
SM_MSGFL3:
	defb "Fill Byte>0x",00h
SM_MSGFL4:
	defb "First: 0x",00h
SM_MSGFL5:
	defb 0dh,"Last:  0x",00h
SM_MSGFL6:
	defb 0dh,"Byte:  0x",00h
SM_MSGFL7:
	defb 0dh,"Fill area?(y)",00h
SM_MSGFL8:
	defb 0dh,"Success filled!",00h
SM_MSGFL9:
	defb 0dh,"Incorrect addr!",00h
SM_MSGFL10:
	defb 0dh,"Fill canceled!",00h
SM_MSGGO1:
	defb "Goto Adr>0x",00h
SM_MSGPGM:
	defb "Page num(0-3)>",00h
SM_MSGRG1:
	defb "Change?(y)",00h
SM_MSGRG2:
	defb ":>",00h
SM_MSGRG3:
	defb "0x",00h
SM_MSGRV1:
	defb "AF:0x0000'0x0000"
	defb "BC:0x0000'0x0000"
	defb "DE:0x0000'0x0000"
	defb "HL:0x0000'0x0000"
	defb "IX:0x0000 I:0x00"
	defb "IY:0x0000 R:0x00"
	defb "       SP:0x0000",00h

SM_MSGVW1:
	defb "View Adr>0x",00h
	
SM_MSGHELP1:
	defb "a - Set address ",00h
	defb "c - Copy block  ",00h
	defb "d - Dump memory ",00h
	defb "e - Edit memory ",00h
	defb "f - Fill block  ",00h
	defb "g - Goto address",00h
	defb "h - This help   ",00h
	defb "p - Page memory ",00h
	defb "r - Registers   ",00h
	defb "q - Quit        ",00h
	defb 00h		; Конец справки
SM_MSGPRENT:
	defb " Enter for more ",00h
; ------------------------------
SM_VARS:
SM_INBUFF:
	defs 06h,00h		; Буфер ввода. До 5 знаков (Десятичное 16bit число) + Код завершения 00h
SM_PRNBUFF:
	defs 05h,00h		; Буфер вывода До 4 знаков (Шестнадцатиричное 16bit число) + Код завершения 00h
SM_VADDR:
	defb 00h,00h		; Текущий адрес устанавливается командой Set Address. С него начинается просмотр, Переход, Редактирование, если не указан иной адрес. По умолчанию #C000 (задаётся при инициализации). СНАЧАЛА СТАРШИЙ БАЙТ!
SM_CADDR:
	defb 00h,00h		; Адрес выбранный при для просмотра или редактирования,  при запуске редактора/просмотрщика копируется из VADDR
SM_MPAGE:
	defb 00h
SM_SADDR:
	defb 00h,00h
SM_EADDR:
SM_DADDR:
	defb 00h,00h
SM_FBYTE:
SM_LENGHT:
SM_RGINP:
	defb 00h,00h
; ------------------------------
SM_RG_AF:
	defb 00h,00h
SM_RG_AFa:
	defb 00h,00h
SM_RG_BC:
	defb 00h,00h
SM_RG_BCa:
	defb 00h,00h
SM_RG_DE:
	defb 00h,00h
SM_RG_DEa:
	defb 00h,00h
SM_RG_HL:
	defb 00h,00h
SM_RG_HLa:
	defb 00h,00h
SM_RG_IX:
	defb 00h,00h
SM_RG_I:
	defb 00h
SM_RG_IY:
	defb 00h,00h
SM_RG_SP:			; Указатель стека для программ пользователя
	defb 00h,00h
SM_RG_SPc:
	defb 00h,00h		; Указатель стека монитора (сохранять перед вызовом пользовательской программы)
