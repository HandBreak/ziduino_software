; *=============================================================================*
; * Библиотека управления i2c устройствами					*
; *										*
; * Доступные функции:								*
; *=============================================================================*
;
	include "pcf8584.asm"
;
;!  i2c_buffer:		equ variables_set + 0080h	; Задействуется для указания адреса devcount (i2c_buffer+1) в ziduino_main - max 129 байт (128 устройств + счетчик)
;!  i2c_devcount:	equ variables_set + 0081h	; Задействуется только со сканером I2C, пересекается с областью текстового буфера меню
;!  ic2_devaddrs:	equ variables_set + 0082h	; ,но не критично так как исполняется только в процессе инициализации, до формирования в буфере списка файлов
    i2c_buffer:		equ variables_set + 0120h	; Задействуется для указания адреса devcount (i2c_buffer+1) в ziduino_main - max 129 байт (128 устройств + счетчик)
    i2c_devcount:	equ variables_set + 0121h	; Задействуется только со сканером I2C
    ic2_devaddrs:	equ variables_set + 0122h	; Перенесено в область, куда ранее производилась загрузка преамбул из EEPROM -> вынесена за пределы 4000h (выше стека, так как может требовать до 7кб пространства)
; ------------------------------
;
; ==============================
; Finding i2C devices
; input:
;	none
; output:
;	none
; ------------------------------
I2C_SCANNER:
	ld de,i2c_devcount 	; Установить начала массива переменных 
	xor a
	ld (de),a		; Инициализировать переменную счетчика устройств i2c
	ld de,I2CMSG1
	rst prn_wascr		; Вывести уведомление о начале сканирования
	call PCF_INIT		; Инициализируем контроллер
	ld d,02h		; начальный адрес поиска i2c устройствами
I2C_SCAN_NEXT:
	push de
	call PCF_MASTER_SCAN	; Произвести сканирование портов
	pop de
	push de
	call nz,I2C_FOUND_MSG	; Если на перечисленном адресе ответило устройство, вызвать сообщение
	cp 0ffh			; Код ошибки FF ? (Устройство не ответило ?)
	call z,I2C_NOTFOUND
	or a
	call z,IC2_BUSBUSY
	pop de
	inc d
	inc d			; адрес увеличиваем двойками
	jr nz,I2C_SCAN_NEXT
	ret			; поиск закончен
	
I2C_FOUND_MSG:			; HL содержит адрес
	push af			; сохраним флаги для последующей проверки
	push hl
	ld a,2
	ld hl,i2c_devcount
	push de			; сохранить bin-код устройства (D)
	inc (hl)		; Увеличить счетчик устройств
	ld c,(hl)		
	ld b,0			; BC=16bit смещение в таблице на количество устройств
	add hl,bc		; Вычислить адрес ячейки хранения
	ld (hl),d		; HL=Текущее значение адреса переменной с кодом устройства
	ld de,I2CMSG2+4		; Адрес знакоместа адреса в буфереs
	call CONV_BINTOHEX
	ld a,","		; Вместо кода завершения строки поставить ","
	ld (de),a		; Перезаписать "конец строки"
	pop af			; Восстановить код устройства в 'A'
	ld hl,I2CDEVLIST	; Начало массива названий
	and 0f0h		; Отсекаем адресацию младшими 3-мя битами
  I2C_SEEK_NAME:	
	ex af,af'		; временно сохранить результат сравнения.
	xor a
  I2C_SEEK_STNAME:	
	cp (hl)			; сравнить с содержимым
	inc hl			; выбрать следующую ячейку
	jr nz,I2C_SEEK_STNAME
	cp (hl)
	jr z,I2C_END_MASSIVE
	ex af,af'
	cp (hl)			; Если небыло 2-го нуля, совападает ли с текущим кодом устройства
  I2C_END_MASSIVE:
	inc hl
	jr nz,I2C_SEEK_NAME	; Если код устройства не совпал, повторить цикл поиска
	ex de,hl		; Тут мы имеем начало строки
	pop hl
	push de
	ld de,I2CMSG2
	rst prn_scr
	pop de
	rst prn_wascr		; Отобразить наименование
	ld de,ENDSTRING
	rst prn_scr
	pop af			; восстановим флаги
	ret
	
I2C_NOTFOUND:
	push af
	ld de,I2CMSG4
	rst prn_scr
	pop af
	ret
IC2_BUSBUSY:
	push af
	ld de,I2CMSG3
	rst prn_scr
	pop af
	ret
; ------------------------------
;
; ==============================
; Random 24LC512 byte read to 
;	buffer
; input:
;	A  - адрес EEPROM
;	DE - адрес в EEPROM
;	из которого произвести чтение
; output:
;	HL - адрес ячейки буфера
;	со считанным байтом
;	none
; ------------------------------
I2C_EEPROM_RDBYTE:
	call I2C_EEPROM_ADR	; Подготовить в буфере адрес чтения
	ld e,2			; Длина последовательности (2 байта адреса)
	push af			; Сохранить адрес i2c EEPROM
	call PCF_MASTER_TX	; HL = Адрес начала буфера передачи данных.  Выполнить запись данных (установка адреса)
	pop de			; Восстановить адрес i2c EEPROM в 'D'
	ld e,01h		; Размер буфера чтения = 1 байт (в 'E')
	ld hl,I2C_EEPROM_WRBUFF	; Буфер чтения данных из EEPROM
	call PCF_MASTER_RX	; Считать байт данных в указанный буфер
	ret			; Выход из процедуры чтения
;
; ==============================
; Reading 24LC512 to memory
; input:
;	A  - адрес EEPROM
;	HL - адрес области для
;	чтения данных
;	DE - адрес в EEPROM
;	с которого произвести чтение
;	BC - размер блока
; output:
;	none
; ------------------------------
I2C_EEPROM_RDDATA:
	push hl			; Сохранить адрес области в которую производить чтение
	push bc			; Сохранить размер блока чтения
	call I2C_EEPROM_ADR	; Подготовить в буфере адрес чтения
	ld e,2			; Длина последовательности (2 байта адреса)
	push af			; Сохранить адрес i2c EEPROM
	call PCF_MASTER_TX	; HL = Адрес начала буфера передачи данных.  Выполнить запись данных (установка адреса)
	pop de			; Восстановить адрес i2c EEPROM в 'D'
	pop bc			; Восстановить размер блока чтения
	pop hl			; Восстановить адрес области памяти, куда производится считывание.
I2C_EEPROM_RDSEQ:		;
	push bc			; Сохранить размер блока
	exx
	pop hl			; HL= размер блока
	ld bc,128		; BC= 128byte
	or a			; Сброс CY
	sbc hl,bc		; уменьшим размер блока на 128
	jr nc,I2C_EEPROM_BFSZ
	add hl,bc		; воссановим HL -> там будет остаточный размер блока (<128 байт)
	ld a,l			; A=остаток от деления (A<128)
	ld l,0			; Обнулить HL
	jr I2C_EEPROM_BFLST
  I2C_EEPROM_BFSZ:
	ld a,c			; Передать размер блока = 128, если HL >128
  I2C_EEPROM_BFLST:
	push hl
	exx
	ld e,a			; E=размер блока
	pop bc			; Восстанавливаем размер блока уменьшенный на 128
	push de			; Сохранить адрес i2c EEPROM в D и размер читаемого блока в E
	push bc			; Сохранить общий размер считываемых данных
	call PCF_MASTER_RX 	; Читаем данные в текущий HL, HL=HL+128
	inc hl			; HL - адрес следующей свободной ячейки буфера чтения
	pop bc			; Восстановить остаточный размер блока
	pop de			; Восстановить адрес EEPROM
	ld a,b
;	ret nz			; Прервать цикл чтения при возникновении ошибки (достигнут конец EEPROM) Флаг=NZ
	or c
	jr nz,I2C_EEPROM_RDSEQ	; Пока BC<>0 продолжить последовательное чтение в текущий адрес HL
	ret			; Чтение закончено успешно,  Флаг=Z
	
;
; ==============================
; Writing byte to 24LC512
; input:
;	A  - адрес EEPROM
;	DE - адрес в EEPROM
;	куда произвести запись
; output:
;	DE - адрес конца буфера
; ------------------------------
I2C_EEPROM_WRBYTE:
	call I2C_EEPROM_ADR	; Подготовить в буфере адрес чтения
	ld e,3			; Длина последовательности (2 байта адреса + 1 байт данных из буфера)
	push de			; Сохранить адрес устройства i2c
	call PCF_MASTER_TX	; HL = Адрес начала буфера передачи данных.  Выполнить запись данных
	pop de			; Восстановить адрес устройства для ожидания записи
	call PCF_EEPROM_WAITWR	; Ожидать завершения записи страницы
	ret			; Выход из процедуры записи	
; ==============================
; Writing page (128byte)
;		to 24LC512
; input:
;	A  - адрес EEPROM
;	DE - адрес в EEPROM
;	с которого начать запись
; output:
;	DE - адрес конца буфера
; ------------------------------
I2C_EEPROM_WRPAGE:
	call I2C_EEPROM_ADR	; Подготовить в буфере адрес чтения
	ld e,130		; Длина последовательности (2 байта адреса + 128 байт данных из буфера)
	push de			; Сохранить адрес устройства i2c
	call PCF_MASTER_TX	; HL = Адрес начала буфера передачи данных.  Выполнить запись данных
	pop de			; Восстановить адрес устройства для ожидания записи
	call PCF_EEPROM_WAITWR	; Ожидать завершения записи страницы
	ret			; Выход из процедуры записи
; ------------------------------
;
; ==============================
; Writing data to 24LC512
; input:
;	A  - адрес EEPROM
;	HL - адрес данных для
;	записи
;	DE - адрес в EEPROM
;	с которого
;	начать запись X128
;	BC - длина блока данных	
; output:
;	none
; ------------------------------
I2C_EEPROM_WRDATA:
	push af			; Сохранить адрес i2c EEPROM
	push de			; Сохранить адрес начала области записи EEPROM	- требуется обеспечить кратность 128
	ld a,128		; Количество копируемых данных
	ld de,I2C_EEPROM_WRBUFF	; DE= адрес буфера данных для записи в EEPROM
  I2C_EEPROM_WRDL1:
	ldi			; Копировать (HL)->(DE), HL++, DE++, BC--
	jp po,I2C_EEPROM_BRK	; Если блок данных закончился, прерываем копирование в буфер
	dec a			; уменьшить счетчик на 1
	jr nz,I2C_EEPROM_WRDL1	; Повторять цикл 128 раз, пока A>0.  На выходе BC= оставшийся размер данных для записи, HL= адреc следующей порции данных для записи, DE=конца буфера записи
	pop de			; Восстановить адрес в EEPROM с которого начинается запись данного блока
	pop af			; Восстановить адрес i2c EEPROM
	call I2C_EEPROM_SEND	; Вызвать процедуру передачи и ожидания
	jr I2C_EEPROM_WRDATA	; Выполнить для следующего блока данных
	
  I2C_EEPROM_BRK:
	pop de
	pop af
	call I2C_EEPROM_SEND	; Вызвать процедуру передачи и ожидания
	ret			; Выход из процедуры записи
; ------------------------------
  I2C_EEPROM_SEND:
	push af			; Сохранить адрес i2c EEPROM
	push hl			; Сохранить адрес начала следующей порции данных для записи
	push de			; Сохранить этот адрес для последующего пересчета
	push bc			; Сохранить остаточную длину блока данных
	call I2C_EEPROM_WRPAGE	; HL = Адрес начала буфера передачи данных.  Выполнить запись данных
	pop bc			; Восстановить остаточную длину блока данных
	pop hl			; восстановить предыдущий адрес EEPROM
	ld de,0080h		;
	add hl,de		; Увеличить адрес записи данных в EEPROM на 128 байт
	ex de,hl		; Результат поместить в DE
	pop hl			; Восстановить адрес следующей порции данных
	pop af			; Восстановить адрес i2c EEPROM
	ret
; ------------------------------
;
; ------------------------------
  I2C_EEPROM_ADR:
	ld hl,I2C_EEPROM_ADRBUFF+1	; HL = Адрес начала буфера записи-1
	ld (hl),e		; Сначала младший байт адреса
	dec hl			; Перейдём к началу буфера
	ld (hl),d		; Затем старший байт адреса (в начало буфера
	ld d,a			; Передаём адрес устройства
	ret
; ------------------------------
I2C_EEPROM_ADRBUFF:
	defb 00h,00h			; 2 Байта адреса перед 128 байтами данных	!!! Работает только при исполнении в Shadow_RAM!!!
I2C_EEPROM_WRBUFF:
	defs 128,00h			; 128 байт данных (страница)			!!! Работает только при исполнении в Shadow_RAM!!!