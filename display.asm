; *=============================================================================*
; * Библиотека управления MT12864 LCD дисплеем					*
; *										*
; * Доступные функции:								*
; *	DISP_INIT		- инициализация дисплейного модуля		*
; *	DISP_ON			- включение дисплея				*
; *	DISP_OFF		- отключение дисплея				*
; *	WAIT_BUSY		- ожидание готовности дисплейного модуля	*
; *	SET_STARTLINE		- установка номера верхней строки		*
; *	CLEAR_SCREEN		- очистка всего экрана				*
; *	FILL_SCREEN		- заливка всего экрана паттерном в 'A'
; *	INVERSE_SCREEN		- инверсия содержимого экрана			*
; *	AREA_FILL		- заполнение указанной области			*
; *	PIXEL_SELECT		- выбор пиксела					*
; *	PIXEL_SET		- установка заданного пиксела			*
; *	PIXEL_RES		- гашение заданного пиксела			*
; *	PIXEL_INV		- инверсия заданного пиксела			*
; *	PIXEL_BIT		- чтение состояния пиксела			*
; *	PIX_CHANGE		- изменение пиксела в соответствии с CY		*
; *	MEM_TO_DISP		- копирование кадрового буфера в видеопамять	*
; *	DISP_TO_MEM		- копирование видеопамяти в кадровый буфера	*
; *	MTD_INT			- режим копирования кадрового буфера по 	*
; *				  прерываниям					*
; * --------------------							*
; *	SYM_DRAW		- формирование символа в соответствии коду ASCII*
; *	PRN_STRING		- вывод строки					*
; *	PRN_WSCROLL		- вывод текстовой строки с прокруткой экрана	*
; *	CLR_STRING		- очистка текстовой строки			*
; *										*
; * Используемые переменные:							*
; *	upline_num		- содержит номер верхней строки дисплея		*
; *	mtd_fcolum								*
; *	mtd_ecolum		- 						*
; *	mtd_eline								*
; *	ADDR_FR_BUFFER								*
; *	fr_buffer_on								*
; *=============================================================================*
;
; Определение адресов хранения используемых переменных:
;dbg_mode:	equ 00h
;port_mode:	equ 01h
upline_num:	equ 02h	; Адрес переменной с номером верхней строки дисплея
mtd_fcolum:	equ 03h	; Адрес переменной с номером первой колонки копируемого блока
mtd_ecolum:	equ 04h	; Адрес переменной с номером последней колонки копируемого блока
mtd_eline:	equ 05h	; Адрес переменной с номером последней строки
;ADDR_FR_BUFFER: equ variables_set + 6	; Адрес переменной, содержащей адрес кадрового буфера DWORD
addr_frb_l:	equ 06h
addr_frb_h:	equ 07h
fr_buffer_on:	equ 08h	; Адрес переменной статуса кадрового буфера ВКЛ/ВЫКЛ
prn_y:		equ 09h	; Позиция курсора по вертикали (L)
prn_x:		equ 0ah	; Позиция курсора по горизонтали (H)

prn_scr:	equ 18h
prn_wascr:	equ 28h
; ------------------------------
;
; ==============================
; MT12864 Init
; input:
;	none
; output:
;	none
; ------------------------------
DISP_INIT:
	ld a,0f0h
	in a,(0bdh)		;
  DIT1:
	in a,(01dh)		;
	and 090h		;
	or a			;
	jr nz,DIT1		;
  DIT2:
	in a,(02dh)		;
	and 090h		;
	or a			;
	jr nz,DIT2		;
	xor a			;
	call SET_STARTLINE	;
	ret			;
; ------------------------------
;
; ==============================
; MT12864 Display ON
; input:
;	none
; output:
;	none
; ------------------------------
DISP_ON:
	ld a,3fh		; A <- Код включения дисплея
	out (03dh),a		; Выводим код в порт управления
	call WAIT_BUSY		; Ожижаем готовности дисплея
	ret			
; ------------------------------
;
; ==============================
; MT12864 Display OFF
; input:
;	none
; output:
;	none
; ------------------------------
DISP_OFF:
	ld a,3eh		; A <- Код выключения дисплея
	out (03dh),a		; Выводим код в порт управления
	call WAIT_BUSY		; Ожижаем готовности дисплея
	ret			;
; ------------------------------
;
; ==============================
; MT12864 Display WAIT
; input:
;	none
; output:
;	none
; ------------------------------
WAIT_BUSY: 
	in a,(01dh)		; Читаем из порта статуса первого кристала
	and 080h		; Оставляем только значимый разряд
	or a			; Проверяем состояние
	jr nz,$-5		; Если кристалл занят, повторяем цикл чтения, иначе
	in a,(02dh)		; Читаем из порта статуса второго кристалла
	and 080h		; Оставляем только значимый разряд
	or a			; Проверяем состояние
	jr nz,$-5		; Если кристалл занят, повторяем цикл чтения, иначе 
	ret			; Выход из цикла ожидания готовности
; ------------------------------
;
; ==============================
; MT12864 Set Start Line
; input:
;	A - номер верхней строки (0-63)
; output:
;	none
; ------------------------------
SET_STARTLINE:
	ld (ix+upline_num),a	;
	or 0c0h			; set START LINE 0-63
	out (03dh),a		;
	call WAIT_BUSY		;
	ret			;
; ------------------------------
;
; ==============================
; MT12864 Clear Screen
; input:
;	A - Паттерн заливки
;	    00h - белый
;	    ffh - черный
; output:
;	none
; ------------------------------
CLEAR_SCREEN:
	xor a
	bit 7,(ix+prn_y)	; Очищаем экран в соответствии с установленным цветом фона (черн/белый)
	jr z,FILL_SCREEN
	cpl
FILL_SCREEN:
	ex af,af'
	ld a,40h		;
	out (03dh),a		; set address 0 to all crystal
	call WAIT_BUSY		;
	ld a,08h		;
	ld b,a			;
  CSN1:
	ld a,40h		;
	ld c,a			;
	ld a,b			;
	dec a			;
	or 0b8h			;
	out (03dh),a		;
	call WAIT_BUSY		;
  CSN2:
	ex af,af'		;
	out (07dh),a		;
	ex af,af'		;
	call WAIT_BUSY		;
	dec c			;
	add a,c			;
	jr nz,CSN2		;
	djnz CSN1		;
	ret			;
; ------------------------------
;
; ==============================
; MT12864 Inverse Screen
; input:
;	none
; output:
;	none
; ------------------------------
INVERSE_SCREEN:
	ld a,40h		;
	out (03dh),a		; set address 0 to all crystal
	call WAIT_BUSY		;
	in a,(05dh)		; \
	call WAIT_BUSY		; -
	in a,(06dh)		; _ дополнительное чтение в соответствии с мануалом к MT-12864A
	call WAIT_BUSY		; / ПРОБЛЕМА !!!  ИЗОБРАЖЕНИЕ СМЕЩАЕТСЯ НА КОЛОНКУ ВЛЕВО!
	ld a,08h		;
	ld b,a			;
  ISC1:
	ld a,040h		;
	ld c,a			;
	ld a,b			;
	dec a			;
	or 0b8h			;
	out (03dh),a		;
	call WAIT_BUSY		;
  ISC2:
	in a,(05dh)		;
	ex af,af'		;
	call WAIT_BUSY		;
	ld a, c			;
	out (01dh),a		;
	call WAIT_BUSY		;
	ex af,af'		;
	xor 0ffh		;
	out (05dh),a		;
	call WAIT_BUSY		;
	in a,(06dh)		;
	ex af,af'		;
	call WAIT_BUSY		;
	ld a,c			;
	out (02dh),a		;
	call WAIT_BUSY		;
	ex af,af'		;
	xor 0ffh		;
	out (06dh),a		;
	call WAIT_BUSY		;
	inc c			;
	ld a,c			;
	cp 080h			;
	jr nz,ISC2		;
	djnz ISC1		;
	ret			;
; ------------------------------
;
; ==============================
; MT12864 Fill Area Screen
; input:
;	H - Column number 0-127
;	L - Line number 0-63
;	B - Number of columns 0-128
;	C - Number of line 0-64
;	A - Command type:
;	     0 - Fill white (pixel off)
;	     1 - Fill black (pixel on)
;	     2 - Fill inverse (pixel xor)
;	     3 - Read (A="00" - pixel off, A<>"00" - pixel on)
;	     4 - Fill data from address in DE reg.
;	     7 - Copy data from display to address in DE reg
;	     8 - Move left block on 1 column
;	    16 - Move right block on 1 column
;	    32 - Move up block on 1 line
;	    64 - Move down block on 1 line
; output:
;	none
; ------------------------------
AREA_FILL:
	call SHIFT_CALC		; Вычислить смещение
	cp 03h			; Режим чтения данных ?
	jr z, PIXBIT		; Если да, перейдём к извлечению состояния заданного бита
	ex af,af'		; Сохранить режим заливки в альтернативном аккумуляторе
	xor a			; Обнулить аккумулятор
	or b			; Счетчик столбцов (B)=0 ?
	ret z			; Выйти из функции, если задано 0 столбцов
	ld d,h			; Сохранить в D номер первого столбца
	ld e,b			; Сохранить в E количество обрабатываемых столбцов
  AREAFILL1:
	xor a			; Обнулить аккумулятор
	or c			; Счетчик строк (C)=0 ?
	ret z			; Выйти из функции, если осталось 0 строк
	ld h,d			; Восстановить исходный номер первого столбца для прохода следующей строки
  AREAFILL2:
	push de			; Сохранить количество обрабатываемых столбцов (E)
	push bc			; Сохранить значения счетчиков строк и столбцов (BC)
	call PIXEL_SELECT	; Выбрать нужный байт в памяти дисплея
	ex af,af'		; Получить режим заливки из альтернативного аккумулятора
	push af			; Сохранить режим в стеке
	call PIXCASE		; Изменить заданный пиксел в текущем адресе памяти
	pop af			; Восстановить режим из стека
	ex af,af'		; 
	pop bc			; Восстановить значения счетчиков строк и столбцов (BC)
	pop de			; Восстановить количество обрабатываемых столбцов (D)
	inc h			; Увеличить счетчик номера колонки на 1
	djnz AREAFILL2		; Уменьшить счетчик столбцов и повторить цикл пока не 0
	ld b,e			; Восстановить исходное значение счетчика столбцов для прохода следующей строки
	dec c			; Уменьшить счетчик строк на 1
	inc l			; Увеличить номер строки на 1
	jr AREAFILL1		; Перейти к проверке достижения последней строки
; ------------------------------
PIXCASE:
	or a			; Режим 0 - ?
	jr z,PIXRES		; Сбросить пиксел, иначе продолжить проверку режима
	cp 01h			; Режим 1 - ?
	jr z,PIXSET		; Установить пиксел, иначе продолжить проверку режима
	cp 02h			; Режим 2 - ?
	jr z,PIXINV		; Инвертировать пиксел, иначе продолжить проверку режима
	ret			; Не выполнять действий, если режим не соответствует диапазону 0-2
; ------------------------------
  PIXEL_SELECT:			; выбор ячейки, содержащей пиксел с указанными координатами (с учетом регистра первой верхней строки)
	ld a,l			; A <-номер строки
	and 3fh			; Ограничим диапазоном 0-63
	ld l,a			; 
	srl a			; \
	srl a			; | - делим на 8 для получения номера страницы
	srl a			; /
	or 0b8h			; Результат объединяем с командой выбора номера страницы
	out (03dh),a		; Пишем номер cтраницы (строки из 8-и точек) в оба кристалла
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ld a,7fh		; В A маску для диапазона значений номера столбца 0-127
	and h			; результат наложения маски на номер столбца сохраняем в A
	ld c,5dh		; В 'С' порт первого кристалла для чтения/записи в память
	bit 6,a			; Определяем в каком кристалле находится искомая колонка  A<64 - 1-й кристалл or A>64 2-ой кристалл
	jr z, PIXSELECT1	; Если номер столбца <64, работаем с первым кристаллом, иначе 
	ld c,6dh		; В 'C' порт второго кристалла для чтения/записи в память
  PIXSELECT1:
	set 6,a			; (or 40h) Команда установки адреса столбца (младшие 5-бит содержат адрес 0-63)
	push af			; Сохраняем актуальную позицию
	out (03dh),a		; Пишем номер столбца в оба кристалла
	call WAIT_BUSY		; Ожидаем готовности
	in a,(c)		; Цикл пустого чтения (в соответствии с мануалом к MT-12864A)
	call WAIT_BUSY		; Ожидаем готовности дисплея
	in a,(c)		; Читаем текущий байт данных из установленного адреса
	ld e,a			; Сохраняем считанный байт в E
	call WAIT_BUSY		; Ожидаем готовности модуля
	pop af			; восстанавливем номер столбца
	out (03dh),a		; Восстанавливаем значение счетчика столбцов после чтения памяти
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ld a,l			; В счетчик номер строки
	and 07h			; Ограничить номером бита в байте
	ld b,a			; B = счетчик сдвига
	ret			
; ------------------------------
  PIXBIT:
	ld a,01h		; выберем пиксел в старшем разряде
  PIXBIT2:
	rlca			; сдвинем вправо (перейдёт в старший разряд)
	djnz PIXBIT2		; повторить сдвиг, пока B<>0
	and e			; проверим выбранный по маске бит. Флаг Z установлен и A=0, если пиксел погашен
	ret			; Выход из подпрограммы установки пиксела
; ------------------------------
  PIXSET:
	ld a,01h		; установим пиксел в старшем разряде
  PIXSET2:
	rlca			; сдвинем вправо (перейдёт в старший разряд)
	djnz PIXSET2		; повторить сдвиг, пока B<>0
	or e			; наложить на существующий байт
	out (c),a		; Запишем байт в данную колонку
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ret			; Выход из подпрограммы установки пиксела
; ------------------------------
  PIXRES:
	ld a,0feh		; сбросим пиксел в старшем разряде
  PIXRES2:
	rlca			; сдвинем вправо (перейдёт в старший разряд)
	djnz PIXRES2		; повторить сдвиг, пока B<>0
	and e			; наложить на существующий байт
	out (c),a		; Запишем байт в данную колонку
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ret			; Выход из подпрограммы установки пиксела
; ------------------------------
  PIXINV:
	ld a,01h		; установим пиксел в старшем разряде
  PIXINV2:
	rlca			; сдвинем вправо (перейдёт в старший разряд)
	djnz PIXINV2		; повторить сдвиг, пока B<>0
	xor e			; инвертировать выбранный по маске бит
	out (c),a		; Запишем байт в данную колонку
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ret			; Выход из подпрограммы установки пиксела
; ------------------------------
PIXEL_SET:
	call SHIFT_CALC		; Вычислить смещение
	call PIXEL_SELECT	; Выбрать нужный байт в памяти дисплея
	jr PIXSET		; Установить заданный пиксел в текущем адресе памяти
; ------------------------------
PIXEL_RES:
	call SHIFT_CALC		; Вычислить смещение
	call PIXEL_SELECT	; Выбрать нужный байт в памяти дисплея
	jr PIXRES		; Сбросить заданный пиксел в текущем адресе памяти
; ------------------------------
PIXEL_INV:
	call SHIFT_CALC		; Вычислить смещение
	call PIXEL_SELECT	; Выбрать нужный байт в памяти дисплея
	jr PIXINV		; Инвертировать заданный пиксел в текущем адресе памяти
; ------------------------------
PIXEL_BIT:
	call SHIFT_CALC		; Вычислить смещение
	call PIXEL_SELECT	; Выбрать нужный байт в памяти дисплея
	jr PIXBIT		; Запросить состояние заданного пиксела в текущей ячейки памяти дисплея
; ------------------------------
PIX_CHANGE:
	jr c,PIXSET		; Устанавливаем пиксел, если CY=1
	jr PIXRES		; Иначе сбрасываем пиксел
; ------------------------------
  SHIFT_CALC:
;------ вычисляем смещение с учетом установленного адреса верхней строки
	push af			; Сохраним тип команды
	ld a,(ix+upline_num)	; Получим текущий номер верхней строки
	add l			; сложим с заданным значением строки
	and 3fh			; ограничим результат диапазоном 0-63
	ld l,a			; передадим результат в регистр номера строки
	pop af			; Восстановим тип команды
	ret			; Возврат из подпрограммы вычисления вертикальной позици с учетом смещения
; ------------------------------
;
; ==============================
; MT12864 Memory To Display Copy
; input:
;	DE - Начало области данных
; output:
;	none
; ------------------------------
MEM_TO_DISP:
	call SHIFT_CALC		; Коррекция начала экрана
	ld a,h
	ld (ix+mtd_fcolum),a	; Сохраним адрес начала строки в переменной
	ld a,b			; Загрузим число колонок в А
	add h			; Суммируем с адресом первой колонки, получим адрес последней колонки
	ld (ix+mtd_ecolum),a	; Сохраним адрес последней колонки
  MEMTOD1:	
	push de			; Сохраняем текущий адрес
	ld a,(de)		; A <-содержимое памяти
	ld d,a			; Далее обрабатываем считанный байт в регистре D
	ld b, 08h		; B = количество итераций в пределах одного байта
  MEMTOD2:
	ld a,(ix+mtd_ecolum)
	cp h			; Если еще не достигнута последняя строка
	jr nz, MEMTOD3		; то вернём в A выводимый бит и перейдём к следующему столбцу
	ld a,(ix+mtd_fcolum)	; Считаем номер первой колонки
	ld h,a			; Восстановим адрес первого столбца
	inc l			; получим номер следующей строки
	dec c			; уменьшим счетчик строк
  MEMTOD3:
	ld a,c
	or a			; Если счетчик строк = 0, прерываем цикл
	jr z, MTD_BREAK		; Если номер строки достиг последней строки, прервём цикл.
	push bc			; Сохраняем количество заполняемых строк и столбцов
	call PIXEL_SELECT	; Вычисляем байт памяти дисплея
	sla d			; CY <-bit7, shift left reg D
	call PIX_CHANGE		; Установить или сбросить пиксел в зависимости от CY
	pop bc			; Восстанавливаем количество заполняемых строк и столбцов
	inc h			; Выбираем следующую колонку
	djnz MEMTOD2		; Перейдём к обработке следующего бита (колонки), уменьшим счетчик B на 1
	pop de			; Восстановим адрес данных
	inc de			; Выберем данные для следующих 8-ми колонок
	jr MEMTOD1		; Повторим весь цикл
  MTD_BREAK:
	pop de			; восстановим текущий адрес данных, вернём на место указатель стека
	ret			; выход их подпрограммы
; ------------------------------
;
; ==============================
; MT12864 Display To Memory Copy
; input:
;	DE - Начало области данных
; output:
;	none
; ------------------------------
DISP_TO_MEM:
	call SHIFT_CALC		; Коррекция начала экрана
	ld a,h
	ld (ix+mtd_fcolum),a	; Сохраним адрес начала строки в переменной
	ld a,b			; Загрузим число колонок в А
	add h			; Суммируем с адресом первой колонки, получим адрес последней колонки
	ld (ix+mtd_ecolum),a	; Сохраним адрес последней колонки
	ld a,c
	ld (ix+mtd_eline),a	; Сохраним в пременной номер последней строки
  DSPTOM1:
	ld bc,0x0800		; В счетчик B загрузим количество обрабатываемых бит в байте, C очистим для дальнейшего заполнения
	push de			; Сохраним текущий адрес памяти
  DSPTOM2:
	push bc
	call PIXEL_SELECT	; Выбираем ячейку экранной памяти
	call PIXBIT		; Получаем состояние искомого бита в A и флаге Z
	pop bc
	neg			; Установим CY, если A<>0 (искомый пиксел зажжен), иначе сбросим CY
	rl c			; bit7<-bit0<-CY
	inc h			; Вычислим адрес следующей колонки
	ld a,(ix+mtd_ecolum)	; В A загрузим адрес колонки следующей за последней обрабатываемой
	cp h			; Вычисленный адрес достиг следующего за последним столбца ?
	jr nz,DSPTOM3		; Пока не достиг выполняме цикл, иначе
	ld a,(ix+mtd_fcolum)	; Считаем номер первой колонки из переменной
	ld h,a			; Восстановим в H номер первой колонки
	inc l			; Вычислим адрес следующей строки, так как предыдущий ряд закончился
	ld a,(ix+mtd_eline)	; Считаем из переменной номер последней строки
	cp l			; Достигли строки следующей за последней ?
	jr z, DTM_BREAK		; Если обработали все строки, прерываем цикл
  DSPTOM3:	
	djnz DSPTOM2		; Выполнить в цикле 8 раз для формирования байта данных
	pop de			; Восстановим текущий адрес памяти
	ld a,c
	ld (de),a		; Сохраним сформированный байт по текущему адресу
	inc de			; Вычислим следующий адрес
	jr DSPTOM1
; ------------------------------	
  DTM_BREAK:
	pop de			; Восстановим текущий адрес данных, вернём на место указатель стека
	ld a,c
	ld (de),a		; Перед выходом запишем последний сформированный байт
	ret			; выход из подпрограммы
; ------------------------------
;
; ==============================
; MT12864 Memory To Display 
;         Interrupt Copy
; input:
;	none
; output:
;	none
; ------------------------------
MTD_INT:
;	ld hl,(ADDR_FR_BUFFER)	; Считаем в HL актуальный адрес кадрового буфера
	ld l,(ix+addr_frb_l)
	ld h,(ix+addr_frb_h)
	ld de,0400h		; В DE загрузим размер буфера
	ld a,0b8h		; Устанавливаем 0-вую страницу
  MTD_INT1:
	out (03dh),a		; Пишем номер cтраницы (строки из 8-и точек) в оба кристалла
	ex af,af'		; Переключимся к теневому аккумулятору
	ld c,05dh		; В регистр C загрузим порт первого кристалла
  MTD_INT2:
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ld a,40h		;
	out (03dh),a		; Пишем адрес нулевой колонки для обоих кристаллов
	ld b,a			; В счетчик B загрузим количество обрабатываемых колонок (64)
  MTD_INT3:
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ld a,e			;
	or d			;
	ret z			; Если счетчик DE=0 закончим цикл и выйдем из подпрограммы
	outi			; Выводим в (C), байт из HL, увеличим HL на 1, Уменьшим B на 1 (Если B-1=0 -> Z=1)
	dec de			; уменьшим счетчик буфера
	jr nz,MTD_INT3
	ld a,c			; В A загрузим текущий адрес кристалла
	ld c,06dh		; В регистр C загрузим порт второго кристалла
	cp c			; Цикл обрабатывал первый или второй кристалл ?
	jr nz,MTD_INT2		; Если обработан только первый кристалл, то вновь пишем адрес нулевой колонки для обоих кристаллов и загружаем в счетчик колонок 64, иначе
	call WAIT_BUSY		; Ожидаем готовности ЖКИ
	ex af,af'		; Вернём в аккумулятор адрес страницы
	inc a			; Выберем следующую страницу (всего 8 - B8-BF)
	jr MTD_INT1		; Повторим весь цикл, но с для новой страницы памяти модуля MT12864
; ------------------------------
;
; Секция кода знакогенератора и
; и обработки текстовых строк
;
; ==============================
; MT12864 Symbol Draw
; input:
; 	H - Column number 0-15
; 	L - Line number 0-7
; 	A - ASCII symbol code
; 	bit7="1" in 'L' display inverse symbol
; 	bit6="1" in 'L' addon symbol and inverse result !! (inverse symbol and addon result!!)
; 	bit5="1" in 'L' display horizontal flip symbol (RESERVED)
; 	bit4="1" in 'L' display vertical flip symbol   (RESERVED)
; 	bit3="1" in 'L' display 90' rotated symbol
; output:
;	none
; ------------------------------
SYM_DRAW:
	ld e,a			; save symbol code
	call SEL_POS		; select position
	ld a,e			; restore symbol code
	ld bc,SYMBOL_DATA	; load to BC start address of ASCII table
	ex af,af'		;
	ld a,d			;
	and 3fh			; выделяем адрес колонки в пределах одного кристала (0-63)
	ld e,a			; производим промежуточное сохранение адреса в свободном регистре E
	ld a,l			; 
	and 0c0h		; выделяем управляющие флаги, переданные через регистр номера столбца
	or e			; объединяем с относительным адресом столбца в пределах кристала из регистра E
	ex af,af'		; 
	ld e,l			; сохраним в bit3 регистра E флаг "обхода" вращения символа
	ld l,a			; В 'L' загружаем код символа
	xor a			; Очищаем A для загрузки '0' в старший разряд смещения адреса 'H'
	ld h,a			; load to HL symbol code from A reg.
	add hl,hl		; \
	add hl,hl		; |-multiple HL*8 (3x(HL*2)) -> HL=table shift
	add hl,hl		; /
	add hl,bc		; first symbol byte address -> HL
	ld a,d			; A <- real (absolute) column address
	ld c,05dh		; C <- 1st crystal output port address
	and 40h			; A <- check  bit 6 (1st or 2nd crypstal)
	jr z,SDRW0		; 
	ld c,06dh		; if A<64 then C <- 2nd crystal output port address
  SDRW0:
	ld d,80h		; D <- mask of move bit
	bit 3,e			; Проверяем атрибут поворота символа на 90`
	jr nz,SDRW4		; if bit3='1' in reg E then goto draw without rotate code
  SDRW1:
	push hl			; save symbol first line address
	ld b,08h		; B <- number of line (8)
	ld e,00h		; E <- clean receiver mask
  SDRW2:
	ld a,(hl)		; A <- per line read symbol image
	inc hl			; select next symbol line
	and d			; A <- bit of actual column (future line)
	neg			; CY <-"1" if mask bit has been set
	rr e			; E,b7 <-(CY), right shift E reg (CY->b7->b6..->b0)
	djnz SDRW2		; repeat 8. On out A=x-bits from first 8 byte 
	pop hl			; restore symbol address
	ex af,af'		; resault send to A
	ld b,a			; В 'B' сохраняем атрибуты управления
	inc a			; increment address (low 6 bits)
	ex af,af'		; Прячем увеличенное значение адреса
	ld a,e			; A <- byte for display
	bit 7,b			; Проверяем признак инверсии изображения
	jr z, SDRW3		; if bit7='0' byte out as it
	cpl			; inverse byte
	ld e,a			; E <- XOR FF byte
  SDRW3:
	bit 6,b			; проверяем признак наложения изображения
	call nz,RD_BYTE		; if bit3='1' then READ byte from display and OR with current byte
	out (c),e		; output column to all display
	call WAIT_BUSY		; waiting for display busy
	rrc d			; right rotate mask (b7->b6->...b0)
	jr nc, SDRW1		; continue, while Mask in D <> 80h
	ret			; exit from draw1 (with rotate)
; ------------------------------
  SDRW4:
	ld b,08h		; в счетчик циклов 'B' загрузить количество формируемых строк
	ld d,e			; save all flags in 'D'
  SDRW5:
	ld a,(hl)		; read symbol byte from actual address
	bit 7,d			; if bit7='0' then goto copy a->e and check bit6,
	jr z,SDRW6		; else
	cpl			; A <- ^A (инвертировать изображение символа)
  SDRW6:
	ld e,a			; Сохранить считанную строку символа в регистре 'E'
	bit 6,d			; Проверить признак "наложения" изображения (bit6='1' ?)
	jr z,SDRW7		; Если "наложение" не требуется, вычислить адрес следующей строки и вывести текущую, иначе
	in a,(c)		; Цикл пустого чтения (в соответствии с мануалом к MT-12864A)
	call WAIT_BUSY		; Подождём готовность дисплея
	in a,(c)		; Читаем текущее значение байта
	or e			; Складываем с выходным байтом
	ld e,a			; Возвоащаем в 'E' результирующий байт
	call WAIT_BUSY		; Ожидаем готовности
	ex af,af'		; Переключаем аккумулятор на счетчик адреса строки
	and 03fh		; Накладываем маску диапазона (0-3F)
	or 40h			; Устанавливаем режим программирования счетчика адреса
	out (3dh),a		; После чтения возвращаем счетчик адреса на исходную (А)???
	inc a			; Увеличиваем значение счетчика адреса
	ex af,af'		; Прячем в теневой регистр счетчик адреса строки
	call WAIT_BUSY		; Ожижаем готовности дисплея
  SDRW7:
	inc hl			; Выбираем адрес следующей строчки символа
	out (c),e		; Выводим предыдущую строку на дисплей
	call WAIT_BUSY		; Ожидаем готовности дисплея
	djnz SDRW5		; Повторяем пока B<>0 (всего 8 раз)
	ret			; exit from draw2 (without rotate)
; ------------------------------
; Subfunction SELECT POSITION
; ------------------------------
  SEL_POS:
; добавляем относительное смещение  
	ld a,(ix+upline_num)	; A <- number page of upstring
	srl a			; \
	srl a			; |- A <- A/8
	srl a			; /
	add l			; A <- сумма смещения и заданной позиции (по номер строки/8)
; конец вычисления смещения
;	ld a,l			; A <- абсолютный адрес (если не учитывать смещение)
	and 07h			; A <- number of line (0-7)
	or 0b8h			; set PAGE number 0-7
	out (03dh),a		; select for all displays
	call WAIT_BUSY		; Ожидаем готовности дисплея
	ld a,h			; A <- Позиция символа на экране (возможно с атрибутами в старших разрядах)
	and 0fh			; A <- number of symbol column (0-15) (отфильтровываем только позицию)
	add a			; \
	add a			; |- A<-A*8
	add a			; / 
	ld d,a			; D <- factory address first column of symbol
	or 40h			; set COLUMN address 0-63
	out (03dh),a		; send column byte to all display crystal
	call WAIT_BUSY		; Ожидаем готовности дисплея
	ret			;
; ------------------------------	
; Subfunction READ BYTE
; ------------------------------
  RD_BYTE:
	in a,(c)		; Цикл пустого чтения (в соответствии с мануалом к MT-12864A)
	call WAIT_BUSY		; Ожидаем готовности дисплея
	in a,(c)		; Читаем текущее значение байта
	or e			; Складываем с выходным байтом
	ld e,a			; Возвоащаем в 'E' результирующий байт
	call WAIT_BUSY		; Держим ожидаем готовности
	ld a,b			; Передаём часть актуального адреса в 'A'
	and 03fh		; Накладываем маску диапазона (0-3F)
	or 40h			; Устанавливаем режим программирования счетчика адреса
	out (3dh),a		; После чтения возвращаем счетчик адреса на исходную (А)???
	call WAIT_BUSY		; Ожидаем готовности дисплея
	ret			; 
; ------------------------------
;
; ==============================
; MT12864 Print String
;	ASCII driver codes 08,0A,0C,0D supported!
; input:
;	HL- First character position, bit7-bit3 of 'L' - attributes
;	DE- Address string in memory
;	in buffer Byte='0' -> end of string
;	bit7="1" in 'L' display inverse symbol
;	bit6="1" in 'L' addon symbol and inverse resoult
;	bit5="1" in 'L' display horizontal flip symbol     RESERVED
;	bit4="1" in 'L' display vertical flip symbol       RESERVED
;	bit3="1" in 'L' display 90' rotated symbol
; output:
;	HL = next symbol position (with all attribs), DE = next symbol in line
;	CY = '1' если места для вывода строки нехватило и произошел досрочный выход из цикла
;	CY = '0' если выход произошел по окончанию строки
; ------------------------------
PRN_STRING:
	ld a,(de)		; считать первый (текущий) байт строки
	or a			; A=0 ?
	ret z			; закончить вывод строки, если достигнут её конец (CY=0)
; 061016-19:46  Добавлено для отправки символа в FT245
	bit 3,(ix+dbg_mode)	; Проверить была ли зажата '*' при включении, если нет то обойти вывод в ttyUSB
	jr nz,PRN_STRING_SKIP_TTY
	out (ft_port),a		; (#F2) Записываем его в порт данных FT245
  PRN_STRING_SKIP_TTY:
; Конец	дополнения 061016-19:46
	cp 08h			; проверить на код BACKSPACE
	jr nz,PSTR6		; Если не код бэкспейса, то продолжить разбор строки, иначе
	inc de			; Выбрать следующий символ
	call PSTR7		; Перейти к процедуре возврата на позицию назад
	ret c			; Выходим из цикла. В L нижняя (7-ая) строка с атрибутами, (CY=1)
	jr PRN_STRING		; Повторяем полный цикл
; ------------------------------
  PSTR6:	
	cp 0ah			; проверить на перевод строки
	jr nz,PSTR0		; Если не перевод, то продолжить далее, иначе
	inc de			; Выбрать следующий символ
	jr PSTR2		; Выбрать адрес следующего символа
; ------------------------------	
  PSTR0:	
	cp 0ch			; проверить на перевод страницы
	jr nz,PSTR4		; Если не перевод страницы, то продолжить разбор строки, иначе
	inc de			; Выбрать следующий символ
	ld h,00h		; Обнулить позицию в строке
	jr PSTR5		; Перейти к вычисленю 0-ой строки
; ------------------------------	
  PSTR4:
	cp 0dh			; проверить на перевод каретки
	jr nz,PSTR1		; Если не перевод, то продолжить далее, иначе
	inc de			; Выбрать следующуй символ
	ld h,00h		; Выбрать первую позицию в строке
	jr PRN_STRING		; Перейти к вычислению следующих позиций символа и строки
; ------------------------------		
  PSTR1:
	cp 7fh			; проверить на код DEL
	jr nz,PSTR9		; Если не код удаления символа, то перейти к печати символа, иначе
;------ проверка на начало экрана
	ld a, l			; Загрузим номер строки
	and 7			; Очистим от атрибутов
	or h			; Объединим с номером столбца
	jr z, PSTR10		; Если достигнута позиция XY=0/0 - игнорировать команду DEL
;------ конец проверки начала экрана
	call PSTR7		; Вызываем процедуру возврата на позицию назад
;	ret c			; Если достигнут конец (начало) экрана выходим из цикла, но с сохранением текущей позиции
	push de			; Сохраняем текущию позицию в строке
	push hl			; Сохраняем позицию на экране и атрибуты вывода
	ld a,20h		; загружаем код пробела
	call SYM_DRAW		; Отрисовываем по вычисленным координатам пробел
	pop hl			; восстанавливаем экранную позицию
	pop de			; восстанавливаем текущую позицию в строке
  PSTR10:
	inc de			; выбираем следующий символ в строке
	jr PRN_STRING		; повторяем цикл	
; ------------------------------	
  PSTR9:
; --- Вставка от 120117 --------  Игнорировать все коды <20h
	cp 20h			; Проверить на соответствие диапазону печатных символов
	jr nc,PSTR11		; Если соответствует - перейти к печати, иначе
	inc de			; Выбрать следующий символ
	jr PSTR2		; Выбрать адрес следующего символа
  PSTR11:
; --- Конец вставки от 120117 ---  
	push de			; сохранить текущий адрес символа
	push hl			; сохранить текущую позицию символа
	call SYM_DRAW		; отрисовать символ с указанными атрибутами и заданным местом
	pop hl			; восстановить позицию символа
	pop de			; восстановить адрес символа
	inc de			; перейти к адресу следующего символа в строке
	ld a,h			; сохранить номер символа в строке в 'A'
	inc a			; увеличить порядковый номер в строке
	and 0fh			; проверить достугнут ли переход на новую строку (bit 3,2,1,0 = 0)
	ld h,a			; возвращаем результат в 'H' (bit 7-4 всегда = 0)
	jr nz,PRN_STRING	; если не достигли конца строки, повторить весь цикл
  PSTR2:
	ld a,l			; A <- номер строки и атрибуты управления
	inc a			; вычислить номер следующей строки
	and 07h			; Проверим выход за пределы области отображения
	jr nz,PSTR3		; Ещё не вышли ? - тогда увеличиваем регистр строки
  PSTR5:
	ld a,l			; Если всё же вышли,  сохраним прежний номер строки в 'A'
	and 0f8h		; Оставим в нём лишь атрибуты управления. Номер обнулим
	ld l,a			; Загрузим результат обратно в регистр строки
	scf			; Устанавливаем признак переноса на начало экрана
	ret			; Выходим из цикла. В L верхняя (0-ая) строка с атрибутами, (CY=1)
; ------------------------------	
  PSTR3:
	inc l			; переходим к следующей строке в пределах экрана
	jr PRN_STRING		; повторяем цикл с самого начала
; ------------------------------		
  PSTR7:
	ld a,h			; сохранить номер символа в строке в 'A'
	dec a			; перейти к адресу предыдущего символа в строке
	and 0fh			; сохранить только младшие четыре бита (0-63)
	ld h,a			; возвращаем результат в 'H' (bit 7-4 всегда = 0)
	xor 0fh			; проверить достугнут ли переход на новую строку (bit 3,2,1,0 = 1)
	ret nz			; если не достигли конца строки, выйти для повтора всего цикла
	ld a,l			; Если всё же вышли, сохраним прежний номер строки в "А"
	dec a			; вычислим номер предыдущей строки
	and 07h			; сохраним три младших значащих бита (диапазон 0-7)
	xor 07h			; Проверим выход за пределы области отображения (верхней строки)
	jr nz,PSTR8		; Еще не вышли ? - идём уменьшать регистр номера строки, иначе
	ld a,l			; сохраним прежний номер строки в "А"
	or 07h			; Установим принудительно  номер нижней строки (три младших бита равны "1")
	ld l,a			; Загрузим результат обратно в регистр строки
	scf			; Установить признак переноса на начало (конец) экрана
	ret			; Выходим из цикла. В L нижняя (7-ая) строка с атрибутами, (CY=1)
; ------------------------------		
  PSTR8:
	dec l			; переходим к предыдущей строке в пределах экрана
	ret			; выход для повтора цикл с самого начала
; ------------------------------	
;
; ==============================
; MT12864 Print With Scroll
; input:
;	none
; output:
;	none
; ------------------------------
PRN_WSCROLL:
	call PRN_STRING		; напечатать строку переданную строку в текущей позиции
	ret nc			; выйти из функции, если строка поместилась на экране, иначе
; ---- данный код заменить на заливку заданной области "белым"
	push hl			; сохраняем координаты текущей позиции и атрибуты
	push de			; сохраняем текущую позицию в строке
	call CLR_STRING		; Вызываем очистку текущей строки
	pop de			; Восстанавливаем позицию в строке
	pop hl			; Восстанавливаем текущую позицию и атрибуты
	ld a,l			; В аккумулятор номер текущей строки с атрибутами
	or 07h			; Сохранив атрибуты, задаём всегда номер нижней строки
	ld l,a			; Возвращаем значение в L
; ---- конец заменяемого кода	
	ld a,(ix+upline_num)	; Загружаем в "A" установленный номер верхней строки
	add 08h			; увеличиваем его на 8 строк
	and 3fh			; Ограничиваем диапазоном 0-63
	push af			; Сохраняем его 
	call SET_STARTLINE	; Вызывем процедуру установки адреса верхней строки
	pop AF			; восстанавливаем номер верхней строки
	ld (ix+upline_num),a	; сохраняем в переменной новый номер верхней строки
	jr PRN_WSCROLL		; допечатываем строку после её перевода
; ------------------------------
;
; ==============================
; MT12864 Clear String
; input:
;	none
; output:
;	none
; ------------------------------
CLR_CURSTRING:
	ld l,(ix+prn_y)		; Получить позицию 
	ld h,(ix+prn_x)		; И режим ввода
CLR_STRING:
	ld b,10h		; В счетчик количество заполняемых пробелом знакомест
  CLR_STR1:
	ld a,20h		; заполняющий символ (пробел)
	push bc			; сохраним счетчик
	push hl			; сохраним позицию
	call SYM_DRAW		; отрисуем символ
	pop hl			; восстановим позицию
	pop bc			; восстановим счетчик
	inc h			; вычислим адрес следующей позиции в строке
	djnz CLR_STR1		; повторяем, пока B<>0
	ret			; Выход
; ------------------------------
;
; ==============================
; MT12864 Clear End String
; input:
;	none
; output:
;	none
; ------------------------------
CLR_ENDSTRING:
	ld l,(ix+prn_y)		; Получить позицию 
	ld h,(ix+prn_x)		; И режим ввода
	ld a,10h		; Длина строки
	sub h			; A=Символов до конца строки
	ld b,a			; Поместить число удаляемых символов в B
	jr CLR_STR1		; Затереть пробелами
; ------------------------------	
;
; ==============================
; MT12864 Clear Under String
; input:
;	none
; output:
;	none
; ------------------------------
CLR_UNDERSTRING:
	ld l,(ix+prn_y)		; Получить позицию 
	ld h,(ix+prn_x)		; И режим ввода
  CLR_NEXTSTR:	
	ld h,0			; Начиная с начала строки
	call CLR_STRING
	inc l			; Следующая строка
	ld a,l
	and 07h			
	jr nz,CLR_NEXTSTR 	; Удалять все строки, пока не достигнем 0-ой
	ret
; ------------------------------	