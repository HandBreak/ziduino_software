; z80dasm 1.1.3
; command line: z80dasm -a --origin=0h --output list.txt ./bios_z80.bin
;
; Таблица смещений относительно начала области переменных
   variables_set:	equ 03b00h	; Начало области переменных для Shadow_RAM. Для работы кода в ROM, требуется вынести за пределы #4000
;! variables_set:	equ 07000h
variables_rom:	equ 04020h	; Альтернативная область переменных для исполнения кода непосредственно из ROM, этот же адрес является альтернативным указателем стека
   mem_clear_area: equ 04000h	; Начало области тестирования и очистки памяти
;! mem_clear_area: equ 08000h	; Начало области тестирования и очистки памяти
   eepromcat_buff:	equ 3ce0h	; = STACK_POINT Начало буфера заголовков файлов. Сразу над стеком (3CE0, 800 байт до конца Shadow_RAM = 28 заголовков Max 27*255=6885 байт)
;! eepromcat_buff:	equ variables_set+120h
dbg_mode:	equ 00h
port_mode:	equ 01h		; Адрес переменной для хранения режима порта конфигурации
menu_skip:	equ 17h		; Переменная для хранение числа пропускаемых строк в меню файлов "SKIP=0..247"
menu_pos:	equ 18h		; Переменная для хранения текущего номера строки меню "POS=1..8"
menu_found:	equ 19h		; Переменная для хренения номера последней найденной записи "FOUND=0.255"
menu_line:	equ 1ah		; Переменная для хранения количества строк меню "LINE=0...8"
menu_disskip:	equ 1bh		; Переменная bit7 =1 разрешает SKIP++, иначе запрещает
menu_bfadrs_l:	equ 1ch		; Переменная для хранения младшего байта адреса буфера заголовков файлов
menu_bfadrs_h:	equ 1dh		; Переменная для хранения старшего байта адреса буфера заголовков файлов
menu_bfcadr_l:	equ 1eh		; Переменная для хранения младшего байта текущего адреса буфера заголовков файлов
menu_bfcadr_h:	equ 1fh		; Переменная для хранения старшего байта текущего адреса буфера заголовков файлов
menu_eepromid:	equ 20h		; Переменная для хранения адреса используемой для запуска EEPROM
menu_auto:	equ 21h		; Переменная для хранения признака разрешения автозапуска из EEPROM
;------------------------------	
	org	0000h
	include "init.asm"	; Инициализация регистров управдления и таймера
	include "memory.asm"	; Тест базовой памяти: ПЕРЕНОС ЗА ОБРАБОТЧИК ПРЕРЫВАНИЙ
;				; Memory.asm осуществляет вызов INIT короткой функцией JR, соответственно перед INIT не допускается вставка кода!!!!!!!
;===============================
; Main loop
;===============================
INIT:
	ex de,hl		; Сохраним адрес последнего байта в DE
	ld hl,STACK_POINT	; Загружаем в hl начальный адрес указателя стека (с начала инициализации не должен был меняться)
	xor a			; сбрасываем флаг CY, обнуляем A
	sbc hl,sp		; Проверяем отличие между начальной установкой стека и текущим состоянием
	ex de,hl		; Восстановим в HL 0000h
	ret nz			; Если различаются - идёт второй цикл, требуется возврат в вызвавшую процедуру
; Copy BIOS from EEPROM to RAM C000
    ld hl,0000h		; Адрес ROM откуда будет копироваться прошивка в теневую RAM !!!! УКАЗАТЬ РЕАЛЬНУЮ ОБЛАСТЬ С КОДОМ
;!  ld hl,4000h	
	ld de,0c000h		; Адрес теневой RAM куда перемещаем прошивку -> далее будет подключен к 0000
	ld bc,3FFFh		; Размер блока данных
	ldir			; Выполним копирование
; Set base memory page	#C000-#FFFF подключаем вместо ROM в область #0000-#4000
	ld a,0ffh		; (   ) Выбираем порт для которого воспроизводится чтение (A14=A15=1, A7=1 RESET)
	in a,(0bdh)		; Читаем из порта (подключаем свободную страницу памяти в область #C000) (по умолчанию дублируется с #0000-#4000)
; Going to main code into RAM
	jr CONT_IN_RAM		; Перейти к исполнению кода из подключенной страницы памяти вместо ROM (требуется, если загружено не 0-го адреса)	
;
; Переход к выполнению кода из
; RAM вместо ROM
; -----------------------------
;
; =============================
; Test memory Error print
; =============================
;
MERRMSG:
	ex af,af'		; Сохраним неверный байт
	ld ix,variables_rom	; Установка области переменны (Альтернативная область вне адресного пространства EPROM)
	ld sp,ix		; Установка альтернативной области для стека в зону за пределами адресного пространства EPROM
	ld a,08h		; Запрещаем дублирование текста в TTY, оставляем только прямой вывод из регистров
	ld (ix+dbg_mode),a	; По умолчанию включаем отладочный вывод в ttyUSB консоль!
	push hl			; HL (Актуальный адрес сохранить в стеке)
	ld b,0b0h		; Загружаем количество импульсов звука нажатия клавиши. Число должно быть чётным!!!
	jp SYS_BEEP_MERR	; Вызываем воспроизведение звукового сигнала при ошибке памяти
  MERRRET:			; Метка для возврата
	ld sp,hl		; Восстановим указатель стека
	ld c,ft_port
	out (c),h		; Вывести в консоль старший байт адрес
	out (c),l		; Вывести в консоль младший байт адреса
	ld a,(hl)		; Считать содержимое памяти
	out (c),a		; Вывести хранящийся байт
	ex af,af'
	ld hl,0001h		; Очищаем HL
	add hl,sp		; HL = Указатель на адрес где хранится код адреса
	push af			; A  = Ожидаемый байт данных (Сохранить в стеке)
	ld bc,MERRSTR2
	ld de,MERRSTR2_RAM	; Буфер для размещения сообщения
  MERRMSG_L1:
	ld a,(bc)
	ld (de),a
	inc bc
	inc de
	or a
	jr nz,MERRMSG_L1
	ld a,2			; Длина текстовой строки
	ld de,MERRSTR2_RAM+2	; Адрес буфера - для записи адреса ошибки
	call CONV_BINTOHEX
	dec hl
	dec hl
	ld a,2
	call CONV_BINTOHEX
	ld a," "		; " "
	ld (de),a		; Закончить пробелом
	ld hl,0001h		; Очищаем HL
	add hl,sp		; HL = Указатель на адрес где хрантся код ожидаемого байта
	ld a,2			; длина строки
	ld de,MERRSTR2_RAM+9	; Адрес буфера - для записанного кода
	call CONV_BINTOHEX
	ld a,","
	ld (de),a
	pop af			; восстановить код ошибки и указатель стека
	pop hl			; восстановить адрес обнаруженной ошибки
	ld a,2
	ld de,MERRSTR2_RAM+14
	call CONV_BINTOHEX
	ld a,0dh
	ld (de),a
	call DISP_INIT		; Инициализируем дисплей
	call CLEAR_SCREEN	; Очищаем дисплей
	call DISP_ON		; Включаем дисплей
	ld hl,0000h		; Загружаем координаты и режим вывода на дисплей в пару HL
	call PRINT_SETPOS	
	ld de,MTSTSTR1		; Загружаем адрес строки с сообщением об ошибке памяти
	rst prn_wascr		; Вызываем печать сообщения на дисплее
	ld de,MERRSTR1
	rst prn_wascr
	ld de,MERRSTR2_RAM
	rst prn_wascr
	ld de,MERRSTR3
	rst prn_wascr
	di
	halt			; Остановка из-за ошибки памяти
; -----------------------------

;-------------------------------
; Точка входа в биос после 
; начальной инициализации и
; копирования ROM -> RAM 
;-------------------------------
CONT_IN_RAM:
; Set variable base address
	xor a
	ld hl,variables_set	; Адрес области переменных
	push hl			; Передаём адрес через стек
	pop ix			; Получаем его в IX
	ld b,7fh		; Проходим весь +диапазон индексного регистра (127 байт)
  VAR_INIT_LP:
	ld (hl),a		; Пишем 00h
	inc hl			; Выбор следующей ячейки
	djnz VAR_INIT_LP	; Цикл инициализации переменных (все обнуляем, включаем ttyUSB, отключаем Frame Buffer, устанавливаем PortMode)
	call MEM_CONFIG		; Установим выбранный режим
; Call Display Init
	call DISP_INIT		; Инициализировать дисплей (сброс кристаллов)
	call DISP_ON		; Включить оба кристалла
	ld hl,0000h		; Позиция вывода XY=0,0
	set 7,l			; Инверсная печать
	call PRINT_SETPOS	; Установить позицию и атрибуты
	call CLEAR_SCREEN
	ld de,MTSTSTR1		; Установить адрес строки cообщения о тестировании базовой памяти
	rst prn_wascr		; Вывести сообщение о тестировании базовой памяти
	ld de,MTSTSTR2
	rst prn_wascr		; Вывести сообщение об успехе "ОК"
	ld de,MTSTSTR3
	rst prn_wascr		; Вывести сообщение о начале тестирования страничной памяти
	push hl			; Сохранить позиции и режим (часть стека сохраняется даже при очистке памяти)
	call MEM_PAGE_TEST	; Вызвать тестирование страничной памяти. !!! ЗАТРЕТСЯ СТЕК И ПЕРЕМЕННЫЕ!!
	and 07h			; Количество страниц памяти (из счетчика) - необходимо преобразовать
	add 30h			; Получим символ
	push af			; Сохранить количество в стеке
	xor a			;
	call SET_STARTLINE	; Восстановим переменную номера верхней строки
	pop af			; Восстановить число страниц памяти
	pop hl			; Восстановиь позиции и режим (часть стека сохраняется даже при очистке памяти)
	call PRINT_SETPOS	; Записать восстановленные значения в переменные
	ld de,MTSTSTR4
	ld (de),a		; Прописать в строке вывода
	rst prn_wascr		; Вывести результат поверх сообщения о начале тестирования
	exx			; В HL сохранить текущие координаты и атрибуты

; Keyboard driver init
	ld a,03h		; Устанавливаем D0D1 в 1 для разрешения миниклавиатуры
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD0,KD1=1)
	out (11110110b),a	; (#F6) Записываем его в порт данных PS/2  (KD2,KD3=1)
	ld bc,0dffeh		; В BC Адрес порта ввода клавиатуры (#FE) и строки (#DF) - нижний ряд
	in a,(c)		; Читаем содержимое порта
	and 08h			; Зажата "*" ?
	ld (ix+dbg_mode),a	; Записать в ячейку '0', если DEBUG_ON, иначе 8
	ld a,03h		; Минимальное время удержание клавиши =A/25 
	ld (ix+scan_count),a	; Установить значение переменной
	ld (ix+scan_stcount),a	; Загрузить значение времени.
	exx			; В HL сохранятся координаты и атрибуты вывода
	ei			; Разрешить прерывания. КОНЕЦ НАЧАЛЬНОЙ ИНИЦИАЛИЗАЦИИ
; ------------------------------	
	xor a
	cp (ix+dbg_mode)
	jr nz,DBGMSG_SKIP	; Проверка режима отладки
	ld de,DBGMSTR1
	rst prn_wascr		; Уведомление о режиме отладки
  DBGMSG_SKIP:	
; ------------------------------
	call I2C_SCANNER	; Поиск i2c устройств
	ld hl,i2c_buffer+01	; в HL адрес счетчика i2c устройств
	ld de,I2CFOUND+04
	xor a
	call CONV_BIN8TODEC	; Преобразовать в DEC формат
	ld de,I2CFOUND
	rst prn_wascr		; Найдено xx устройств
	ld de,I2CFOUND2
	rst prn_scr		; Законцовка сообщения о найденных устройствах
; ------------------------------; Поиск EEPROM начиная со старшего адреса и попытка загрузки
	ld hl,i2c_buffer+01	; в HL адрес счетчика
	ld a,(hl)		; Считать количество найденных
	ld c,a
	ld b,0
	add hl,bc		; Вычислить адрес последней ячейки списка i2c устройств
	ex de,hl
	or a
	ld (ix+menu_eepromid),a	; Инициализировать eepromid -> если нет i2c, обнулить
	jr z,ROM_LOADER		; Если обнаружено 0 i2c устройств перейти к загрузчику из ROM_LOADER. Иначе
  FIND_I2C_EEPROM:
	ld a,(de)
	and 0f0h		; Оставим только значимую часть адреса
	cp 0a0h			; Адрес из диапозона A0-AE ? (начиная со старшего.)
	push de			; Сохранить адрес записи i2c устройства
	push bc			; Сохранить счетчик C
	call z,FOUND_I2C_EEPROM	; Обнаружено EEPROM, уведомление и попытка загрузки
	ld l,(ix+menu_bfcadr_l)
	ld h,(ix+menu_bfcadr_h)
	ld e,(ix+menu_bfadrs_l)
	ld d,(ix+menu_bfadrs_h)
	or a			; На всякий случай сбросить CY
	sbc hl,de		; Если 0, значит ничего не нашлось, переходим к поиску в следующей EEPROM или ROM, иначе
	jr nz,ROM_LDR		; Если что-то найдено, перейдём к формированию меню из данных заголовков + заголовков зашитых в ROM
	ld de,EEPROM_MSG6	; Файлы не найдены!
	rst prn_scr		; Вывести уведомление
	pop bc			; Восстановить счетчик C
	pop de			; Восстановить адрес записи
	dec de			; Выбрать предыдущую переменную для сравнения
	dec c			; Уменьшить порядковый номер переменной
	call nz,NEXT_EEPROM_SKIP; Вызвать меню пропуска загрузки с другой EEPROM, если есть ещё i2c устройства
	jr nz,FIND_I2C_EEPROM	; Продолжать поиск пока не дошли до начала списка
; Переходим к поиску и загрузке из ROM
  ROM_LOADER:
	ld de,ROM_LOADING	; Уведомление о начале поиска в ROM_LOADER
	rst prn_scr		; Вывести уведомение
  ROM_LDR_WAIT_KEY:
	halt			; Ждём прерывания
	ld a,(ix+scan_code)	; Читаем содержимое клавиатурного буфера
	cp 7fh			; Проверяем на соответствие кнопке "#"
	ld (ix+scan_code),00h	; Очистим буфер
	jr z,ROM_LDR_CONT	; Если нажата перейти к поиску и загрузке из ROMa
	call PS2CODE_CONVERT	; Проверка буфера PS/2 клавиатуры
	cp 0ah			; Нажата клавиша 'ENTER' ?
	jr z,ROM_LDR_CONT
	jr ROM_LDR_WAIT_KEY	; Продолжаем ожидать нажатие клавиш
; ------------------------------	
  ROM_LDR:
	pop bc			; Восстановить стек после FIND_I2C_EEPROM
	pop de			; Восстановить стек после FIND_I2C_EEPROM
  ROM_LDR_CONT:
	call ROM_MENU		; Вызвать меню
	cp b			; Если A=B, произвести запуск программы
	call z,MENU_EXECUTE
	jr ROM_LDR_CONT		; Обратно в меню
; ------------------------------	
NEXT_EEPROM_SKIP:
	ld a,(de)		; Считать идентификатор следующего устройства
	and 0f0h		; Оставить значимую часть адреса
	cp 0a0h			; Оно относится к EEPROM ?
	ret nz			; Если это не EEPROM, то выходим с NZ для продолжения сканирования, иначе
	push de			; сохраним адрес переменной
	push bc			; сохраним счетчик
	ld de,EEPROM_MSG7
	rst prn_scr
  NEXT_EEPROM_WKEY:	
	halt			; Ждём прерывания
	call PS2CODE_CONVERT	; Проверка буфера PS/2 клавиатуры
	cp 1fh			; Ничего не нажато
	jr z,NEXT_EEPROM_WKEY	; Продолжаем пока нет нажатий
	pop bc			; Восстановим счетчик
	pop de			; Восстановим адрес переменной
	cp 6eh			; Нажатая клавиша 'N' ?
	jr nz,NEXT_EEPROM_SZ	; Не 'N' - установить Z
	or a
	ret			; Возврат с флагом NZ (OR 31 <>0) если нажата N. Иначе
  NEXT_EEPROM_SZ:
	sub a			; A=A-A -> всегда 0 ->Возвращаем флаг Z, для пропуска поиска на другой EEPROM
	ret			; Выход и загрузка из ROM
	
; ------------------------------
; Формирование меню файлов
; ------------------------------
  ROM_MENU:
	xor a
	ld (ix+menu_skip),a	; Сбросить счетчик пропускаемых записей
	inc a
	ld (ix+menu_pos),a	; Установить счетчик позиции курсора меню на 1-й пункт
  MENU_LOOP:			; Цикл формирования меню
	xor a			;
  	ld bc,TEXT_BUFFER	; BC=Буфер текста для вывода меню
	ld (ix+menu_found),a	; Сбросить счетчик последней найденной записи
	ld (ix+menu_line),a	; Сбросить счетчик найденных строк
   ld hl,0000h		; Адрес начала поиска.
;! ld hl,4000h		; Адрес начала поиска.
  MENU_LOOP1:
	call FIND_HEADER_CONT	; Вызвать процедуру поиска преамбулы
	cp 55h
	jr z,MENU_CHECK_LINE0	; Если совпала, идти провеерять LINE=0?, иначе HL указывает на адрес последнего найденного заголовка A=0
	inc (ix+menu_found)	; FOUND++  Увеличить счетчик последней найденной записи на 1
	ld a,(ix+menu_skip)	; Загрузить в аккумулятор число пропускаемых строк
	cp (ix+menu_found)	; Сравнить с числом найденных настрок
	jr nc,MENU_LOOP1	; Если FOUND>SKIP, то продолжим (CY=1), иначе начать цикл заново (увеличился FOUND, и адрес поиска HL)
	ld a,(ix+menu_line)	; Загрузить для проверки число переданных в буфер строк
	cp 08h			; Достигнуто 8?
	jr nc,MENU_SKIP_ENABLE	; Если LINE достигло 8, перейдём к отрисовке меню, иначе продолжим наполнять буфер и увеличим LINE
	inc (ix+menu_line)	; LINE++
  MENU_BUFF_COPY:
	ld a,(hl)		; Считать первый символ названия
	ld (bc),a		; Записать его в текущий адрес буфера
	inc hl			; Выбрать следующий адрес символа
	inc bc			; Выбрать следующий адрес буфера
	or a			; Это конец строки ? (A=0)
	jr nz,MENU_BUFF_COPY	; Выполнять копирование, пока не достигнем конца строки
	jr MENU_LOOP1		; Выполнить продолжить цикл сбора заголовков в буфер
; ------------------------------
  MENU_CHECK_LINE0:		; A=0, после нахождения заголовка
	cp (ix+menu_line)	; LINE=0 ?
	ret z			;
	inc (ix+menu_found)	; FOUND++  Корректируем счетчик для последующего вычисления номера записи
	res 7,(ix+menu_disskip)	; Сбросить bit7 (запретить прокрутку списка, так как список <=8 строк)
	jr MENU_SKIP_DISABLE
  MENU_SKIP_ENABLE:
	set 7,(ix+menu_disskip)	; Установить bit7 (разрешить прокрутку списка, так как список >8 строк
  MENU_SKIP_DISABLE:
; ------------------------------
	call NEW_WHITE_SCREEN	; Очистить экран перед прорисовкой меню, установить позиции X,Y=0,0
	xor a			; COUNT=0
	ld de,TEXT_BUFFER	; DE= начало текстового буфера для вывода
  MENU_PRN_LOOP:		; Цикл вывода меню
	cp (ix+menu_line)	; COUNT<LINE ?
	jr nc,MENU_KEYREAD	; Если нет (COUNT>=LINE), читать клавиатуру, иначе
	inc a			; COUNT++
	cp (ix+menu_pos)	; COUNT=POS ?
	push af			; Сохранить счетчик строк
	ld a,00h		; Инверсия выключена
	jr nz,MENU_PRN_NOINV	; Если не совпали - печать без инверсии, иначе
	ld a,80h		; bit7=1 включать инверсию
  MENU_PRN_NOINV:		; Обход включения инверсии
	push af			; сохранить A (80/00 - инверия/нет)
	xor (ix+prn_y)		; инвертировать атрибут инверсии, если A=80h
	ld (ix+prn_y),a		; записать результат
	rst prn_wascr		; Отпечатать строку в текущую позицию из текущего адреса
	inc de			; Перейти к началу следующей строки
	pop af			; восстановить A (80/00 - инверсия/нет)
	xor (ix+prn_y)		; инвертировать атрибут инверсии, если A=80h
	ld (ix+prn_y),a		; записать результат
	pop af			; Восстановить счетчик строк
	jr MENU_PRN_LOOP	; Продолжить вывод меню
; ------------------------------
  MENU_KEYREAD:
	call MENU_CHKAUTORUN 
	ld c,a			; Передаём номер загружаемой записи (либо FF, тогда нет автозапуска)
	ld l,20			; Звуковой отсчет после 1-ой секунды ожидания
MENU_KEYREADLP:
	ld (ix+scan_code),00h	; Очистим буфер клавиатуры
	halt			; Подождать прерывание
	push bc	
	push hl			; сохранить счетчик интервала звуковых сигналов	
	call PS2CODE_CONVERT	; Проверка буфера PS/2 клавиатуры
	pop hl			; восстановить счетчик интервала звуковых сигналов
	pop bc
	ld a,(ix+scan_code)	; Читаем содержимое клавиатурного буфера
	cp 1bh			; Нажат ESC ?
	jr nz,MENU_KEYRDSKP
	ld b,00h
	ret
MENU_KEYRDSKP:
	cp 7fh			; Проверяем на соответствие кнопке "#"
	jr z,MENU_ENTERKEY	; Если нажата # перейти к вычислению адреса и запуску
	cp "2"			; Проверим на нажатие "2" (вниз)
	jr z,MENU_UPKEY		; Если нажата, перейти к обработке
	cp "8"			; Проверим на нажатие "8" (вниз)
	jr z,MENU_DOWNKEY	; Если нажата, перейти к обработке
	cp 0ah			; Нажата клавиша 'ENTER' ?
	jr z,MENU_ENTERKEY	; Если нажата ENTER PS/2 перейти к вычислению адреса и запуску
	cp 18h			; Если нажата стрелка вверх
	jr z,MENU_UPKEY		; Если нажата, перейти к обработке
	cp 0bh			; Если нажата стрелка вниз
	jr z,MENU_DOWNKEY	; Если нажата, перейти к обработке
	ld a,0ffh
	cp b
	jr z,MENU_KEYREADLP	; Если Было получено FF, автозапуск отключен. Иначе работает таймер по полученнму значению
	call MENU_AUTOSND	; Воспроизводить звуковой отсчет, если работает таймер
	djnz MENU_KEYREADLP	; Продолжаем ожидать нажатие клавиш или истечения времени
	ld a,c			; Загружаем номер записи в счетчик (далее будет перегружен в B)
	jr MENU_AUTOENTERKEY
; ------------------------------
  MENU_UPKEY:
	ld a,1
	cp (ix+menu_pos)	; POS>1 ?
	jr nc,MENU_SKUP_CHK	; Если POS>1 то продолжить дальше, иначе перейти к проверке и уменьшению SKIP
	dec (ix+menu_pos)	; POS--
	jp MENU_SKIP_DISABLE	; Перейти к циклу отрисовки меню со сбросом COUNT в 0
; ------------------------------
  MENU_DOWNKEY:
	ld a,(ix+menu_pos)
	cp (ix+menu_line)	; POS<LINE ?
	jr nc,MENU_SKDW_CHK	; Если POS<LINE (CY=1), то продолжить, иначе перейти к
	inc (ix+menu_pos)	; POS++
	jp MENU_SKIP_DISABLE	; Перейти к циклу отрисовки меню со сбросом COUNT в 0	
; ------------------------------  
  MENU_SKUP_CHK:
	xor a
	cp (ix+menu_skip)	; SKIP>0 ?
	jp nc,MENU_LOOP		; Если SKIP=0, то перейти к началу цикла меню
	dec (ix+menu_skip)	; SKIP--
	jp MENU_LOOP		; Перейти к началу цикла меню
; ------------------------------
  MENU_SKDW_CHK:
	bit 7,(ix+menu_disskip)	; Проверить bit7 (Прокрутка разрешена ? bit7=1 ?)
	jp z,MENU_LOOP		; Если прокрутка запрещена - перейти к началу цикла меню, иначе
	inc (ix+menu_skip)	; SKIP++
	jp MENU_LOOP		; Перейти к началу цикла меню
; ==============================
	
	
; --- запуск программы из памяти
  MENU_ENTERKEY:
	ld a,(ix+menu_found)	; Вычисляем номер записи выбранной преамбулы, начиная с "1"
	dec a			; Корректируем количество найденных записей
	sub (ix+menu_line)	; вычитаем количество строк в меню (получаем номер верхней записи)
	add (ix+menu_pos)	; добавляем номер позиции
MENU_AUTOENTERKEY:	
	ld b,a			; Загрузим количество записей в счетчик
	ret			; Возврат в цикл вызова для последующего запуска
MENU_EXECUTE:
	ld (ix+menu_auto),00h	; запретить работу таймера до перезагрузки
   ld hl,0000h		; адрес начала области поиска
;! ld hl,4000h		; адрес начала области поиска
  MENU_FIND_REC:
	call FIND_HEADER_CONT	; произвести поиск преамбулы
	djnz MENU_FIND_REC	; выполнять поиск преамбулы B раз - HL=адрес заголовка
	add hl,de		; Вычисляем адрес конца заголовка (всегда содержит 00h)
	inc hl			; HL - указывает на адрес смещения (2 байта)
	ld e,(hl)		;
	inc hl			;
	ld d,(hl)		; DE - Смещение
	ld a,e
	or d			; DE=0 ?
	push de			; Сохранить адрес смещения для использования с i2c
	push af			; Сохранить результ проверки смещения
	inc hl
	ld a,(hl)		; Читаем номер страницы
	call MEM_CONFIG		; Включить запрошенную страницу памяти
	inc hl
	ld e,(hl)
	inc hl
	ld d,(hl)		; DE - Адрес размещения и запуска
	inc hl
	ld c,(hl)
	inc hl
	ld b,(hl)		; BC - Длина копируемого блока
	inc hl			; HL - Адрес начала блока данных в ROM
	pop af			; Восстановить результат проверки смещения
	jr nz,FROM_EEPROM	; Если нет, вызвать копирование из EEPROM, иначе
	pop af			; Восстановить стек (было сохранено DE=0 для i2c)
	push de			; Сохранить в стеке адрес запуска
	ldir			; Скопировать блок данных в область исполнения
	pop hl			; Адрес запуска в HL
	jp (hl)			; Передать управление в начало программы. Выход произойдёт в ROM_LDR_CONT: (DI HALT)
; ------------------------------
FROM_EEPROM:			; Запуск программы из EEPROM (Если смещение <>0)
	pop hl			; В HL надо получить адрес смещения (размещения кода в EEPROM. Было сохранено из DE)
	push de			; Сохранить в стеке адрес запуска	
	ex de,hl		; DE <-Адрес смещения в EEPROM, HL <-Адрес RAM для загрузки и запуска
	ld a,(ix+menu_eepromid)	; Загрузить идентификатор i2c EEPROM
	call I2C_EEPROM_RDDATA	; Читать блок данных заданного размера с указанного адреса EEPROM в RAM по адресу DE
	pop hl			; Адрес запуска в HL
	jp (hl)			; Передать управление в начало программы. Выход произойдёт в ROM_LDR_CONT: - цикл меню
; ------------------------------	

  FOUND_I2C_EEPROM:		; Уведомление о наличии EEPROM и попытка с него загрузиться HL=адрес кода
	ld a,(de)		; Получить идентификатор выбранной EEPROM
	ld (ix+menu_eepromid),a	; Сохранить идентификатор активной EEPROM
   ld hl,eepromcat_buff	; !!!!! Адрес буфера заголовков, перенесён за пределы Shadow_RAM, так как может достигать 6,8кб для 255 файлов
;! ld hl,variables_set+120h; !!!!! Адрес буфера заголовков, начинается сразу за 160-байтным текстовым буфером меню
	ld (ix+menu_bfadrs_l),l
	ld (ix+menu_bfadrs_h),h	; Инициализируем переменную начального адреса буфера
	ld (ix+menu_bfcadr_l),l
	ld (ix+menu_bfcadr_h),h	; Инициализируем переменную текущего адреса буфера
	ex de,hl		; HL <-Адрес числа из DE
	ld a,2
	ld de,EEPROM_MSG1+13	;
	call CONV_BINTOHEX	; Вписать адрес EEPROM в строку вывода.  HL-переменная в которой адрес i2c
	ld a," "
	ld (de),a
	ld de,EEPROM_MSG1
	rst prn_scr		; Найдено сообщить о попытке загрузки
 	ld hl,0000h		; Загрузим в HL адрес начала области поиска в EEPROM
  FIND_EEPROM_NEXT_PRE:
 	ld c,(ix+menu_eepromid) 	
 	call FIND_EEPROM_CONT	; Вызываем поиск преамбулы в EEPROM начиная с адреса 0000h и заканчивая fffeh. На выходе HL-адрес первого заголовка, после преамбулы (A=00h), или не найдено (A=55h)
	push hl			; Сохранить адрес на котором завершен поиск
	cp 55h			; Если преамбулы не найдены, уведомить об отсутствии файлов на EEPROM
	push af
	call z,EEPROM_READED	; Отобразить уведомление о завершении поиска на текущей EEPROM
	pop af
	pop hl			; Восстановить адрес на котором был завершен поиск
	ret z			; Вернуться в процедуру старта для поиска файлов на следующей EEPROM или запуска из ROM BIOS, если на данной EEPROM поиск завершен
	ld de,0003h		; Отступ назад от заголовка для захвата преамбулы
	or a			; Сбросить CY
	sbc hl,de		; HL - адрес найденной записи, начиная с 55AAAA
	ld e,(ix+menu_bfcadr_l)
	ld d,(ix+menu_bfcadr_h)	; Загрузить в счетчик адреса приёмника текущее значение свободной области буфера
	ex de,hl		; DE - адрес EEPROM с которого начать копирование, HL - адрес приемного буфера
	ld bc,27		; Размер копируемого блока = 27 байт
	push hl			
	pop iy			; HL->IY (Адрес начала копируемой преамбулы)
	push de			; Сохранить адрес начала копируемого из EEPROM блока
	ld a,(ix+menu_eepromid)
	call I2C_EEPROM_RDDATA	; Скопировать блок данных в область по адресу DE
	ld (ix+menu_bfcadr_l),l
	ld (ix+menu_bfcadr_h),h	; Сохраним адрес начала свободной области буфера чтения
	pop hl			; Восстановить адрес с которого начинался данный блок в HL
	ld c,(iy+25)		; Загружаем младший байт длины блока
	ld b,(iy+26)		; Загружаем старший байт длины блока
	add hl,bc		; К адресу начала скопированного блока прибавим его длину без учета заголовка
	ld bc,27		; размер заголовка
	add hl,bc		; HL=Адрес начала следующего заголовка (пропускаем область содержащую код программы
	jr FIND_EEPROM_NEXT_PRE	; Перейти к поиску и копированию следующей преамбулы
; ------------------------------
EEPROM_READED:
	ld de,EEPROM_MSG2	; EEPROM прочитано
	rst prn_scr		; Сообщить о завершении поиска
	ld (ix+menu_auto),0ffh	; После нахождения EEPROM автозапуск разрешен
	ld b,30
  EEPROM_RD_MSGWAIT:
	halt
	push bc
	call PS2CODE_CONVERT
	pop bc
	ld a,(ix+scan_code)
	or a
	jr z,EEPROM_RD_MSGWAITLP; Если ничего не нажималось, автозапуск не отменяем
	ld (ix+menu_auto),00h	; Иначе запретить автозапуск
  EEPROM_RD_MSGWAITLP:
	djnz EEPROM_RD_MSGWAIT	; 1,5 секунды на отображение уведомления
	ret
; ==============================
; Поиск заголовка в RAM/ROM
; ==============================
;
FIND_HEADER_CONT:
     ld de,eepromcat_buff + 1b1bh	; !!!! адрес конца области поиска (Включая буфер для заголовков из EEPROM. находится по адресу 4000h)
;!   ld de,5800h	; !!!! адрес конца области поиска (Включая буфер для заголовков из EEPROM. находится по адресу 4000h) ~ 3ce0 + 1b1b
  FIND_HEADER_L2:
	ld a,0aah		; Начало !преамбулы заголовка файла
  FIND_HEADER_L1:
	or a
	cpl	
	sbc hl,de
	ret nc			; Если HL=>DE, закончить поиск A=55h
	add hl,de
	cp (hl)			; Ищем 55h
	inc hl			; Следующий адрес
	cpl			; инвертировать 'A' (55->AA) (поиск преамбулы)
	jr nz,FIND_HEADER_L1	; Повторять пока не совпадает
	cp (hl)			; Ищем AAh
	inc hl			; Следующий адрес
	jr nz,FIND_HEADER_L1	; Повторять пока не совпадает, иначе ожидается заголовок
	cp (hl)			; Ищем повторный AAh
	inc hl			; Следующий адрес
	jr nz,FIND_HEADER_L1	; Повторять пока не совпадает, иначе ожидается заголовок	
	ld de,0010h		; Длина заголовка 16 байт (должен заканчиваться 00h)
	add hl,de		; Находим адрес конца заголовка
	ld a,(hl)		; читаем в A (ожидается 0)
	sbc hl,de		; Восстанавливаем адрес начала заголовка
	or a			; A=0 ?
	jr nz,FIND_HEADER_CONT	; Это был не заголовок, иначе в HL Адрес начала заголовка
	ret			; HL=адрес строки заголовка Z=1,A=00h
	
; ==============================
; Поиск заголовка в EEPROM
; ==============================
;
FIND_EEPROM_CONT:
	ld a,0aah		; Начало !преамбулы заголовка файла
  FIND_EEPROM_L1:
	ld de,0ffffh		; адрес конца области поиска
	or a
	cpl	
	sbc hl,de
	ret nc			; Если HL=>DE, закончить поиск A=55h
	add hl,de
	call FIND_EEPROM_CPBYTE	; Ищем 55h
	inc hl			; Следующий адрес
	cpl			; инвертировать 'A' (55->AA) (поиск преамбулы)
	jr nz,FIND_EEPROM_L1	; Повторять пока не совпадает
	call FIND_EEPROM_CPBYTE	; Ищем AAh
	inc hl			; Следующий адрес
	jr nz,FIND_EEPROM_L1	; Повторять пока не совпадает, иначе ожидается заголовок
	call FIND_EEPROM_CPBYTE	; Ищем повторный AAh
	inc hl			; Следующий адрес
	jr nz,FIND_EEPROM_L1	; Повторять пока не совпадает, иначе ожидается заголовок	
	ld de,0010h		; Длина заголовка 16 байт (должен заканчиваться 00h)
	add hl,de		; Находим адрес конца заголовка
	push af			; Сохранить CY после сложения
	push de			; Сохранить размер заголовка для последующего вычитания
	call FIND_EEPROM_CPBYTE	; Ищем 00h
	pop de			; Восстановить размер заголовка
	pop af			; Восстановить CY (результат сложения)
	ld a,b			; Прочитанный байт в A <-B
	sbc hl,de		; Восстанавливаем адрес начала заголовка (ПОСЛЕ преамбулы!!)
	or a			; A=0 ?
	jr nz,FIND_EEPROM_CONT	; Это был не заголовок, иначе в HL Адрес начала заголовка
	ret			; HL=адрес строки заголовка Z=1,A=00h

  FIND_EEPROM_CPBYTE:
	push af			; Сохранить искомый код
	push hl			; Сохранить адрес запрашиваемой ячейки
	ex de,hl		; DE=Адрес ячейки EEPROM для поиска
	ld hl,I2C_EEPROM_WRBUFF	; HL=Адрес промежуточного буфера
	ld a,c			; A=адрес EEPROM
	push bc			; Сохраним адрес i2c из C	
	call I2C_EEPROM_RDBYTE	; Вызвать чтение байта из указанного адреса EEPROM в буфер HL
	pop bc			; Восстановим адрес i2c в С
	ld b,(hl)		; B=считанный байт
	pop hl			; Восстановить адрес запрашиваемой ячейки
	call FIND_EEPROM_DOTS	; Изобразить многоточие
	pop af			; Восстановить искомый код
	cp b			; Ищем 55h/AAh
	ret

  FIND_EEPROM_DOTS:
	ld a,l			; Для проверки берём младший байт текущего адреса поиска
	or a			; Если он <>0 то ничего не печатаем
	ret nz			; и выходим
	push bc			; иначе сохраняем единственную значимую пару регистров BC
	push hl
	ld a,h			; Старший байт адреса сохраним в A
	and 0ch			; Выделяем из старшего байта адреса биты 3 и 4 - будут определять число точек
	cp 0ch			; Если A=12, тоже ничего не печатаем
	jr z,FIND_EEPROM_DOTS_SKIP
	ld l,a
	ld h,0			; HL=0:A
	ld de,EEPROM_MSG3	; Адрес строки с 1-ой точкой
	add hl,de		; Вычисляем адрес строки для печати
	ex de,hl		; Адрес строки -> DE
	ld l,(ix+prn_y)
	ld a,(ix+prn_x)
	sub 03h			; Вычисляем позицию печати
	ld h,a
	call PRN_STRING
  FIND_EEPROM_DOTS_SKIP:
	pop hl
	pop bc
	ret
; ----------------------
MENU_CHKAUTORUN:
	ld de,0fffeh		; DE=Адрес ячейки EEPROM для поиска (Предпоследний байт EEPROM)
	ld a,(ix+menu_eepromid)	; Загрузить идентификатор i2c EEPROM
	and (ix+menu_auto)	; Если EEPROM отсутствует или запрещён автозапуск (auto=00)
	jr z,MENU_CHKAUTORUN2	; Передать через B #FF и выйти
	push de
	call I2C_EEPROM_RDBYTE	; Вызвать чтение байта из указанного адреса EEPROM в буфер HL
	pop de
	inc de			; Выбрать ячейку FFFF
	ld a,(hl)		; B=считанный байт
	ld b,a			; Счетчик таймера (в 1/20 сек)
	cp 0ffh			; Если по указанному адресу пусто (#ff), автозапуск выключен - продолжить ожидание клавиши:
	ret z
	or a
	jr nz,MENU_CHKAUTORUN1	; Если <>0, перейдём к получению номера записи
  MENU_CHKAUTORUN2:
	ld b,0ffh
	ret			; Вернём в (#ff), на случай отсутствия EEPROM или недопустимой записи в ней '00'
  MENU_CHKAUTORUN1:
	push bc			; Сохраним в B значение таймера
	ld a,(ix+menu_eepromid)	; Загрузить идентификатор i2c EEPROM
	call I2C_EEPROM_RDBYTE	; Вызвать чтение байта из указанного адреса EEPROM в буфер HL
	ld a,(hl)		; A=Номер запускаемой подпрограммы
	pop bc			; B=Значение таймера
	ret
; ----------------------
  MENU_AUTOSND:
	ld a,(PS2_RAWDATA)	; Проверяем состояние линии CLOCK
	bit 2,a			; Если CLOCK = 0, значит в этом прерывании обрабатывалась PS/2
	ret z			; Выйти, если прерывание было по сигналу CLOCK от PS/2
	dec l			; Уменьшить счетчик на 1
	ld a,l
	ret nz			; Выйти пока <>0
	push bc
	ld b,30h		; Длительность звукового сигнала
	call SYS_BEEP		; Воспроизвести звук таймера
	pop bc			; Восстановить счетчики
	ld l,20			; Установить интервал между сигналами  20 * 1/20 = 1 сек
	ret			; Вернуться в цикл ожидания клавиатуры
; ----------------------
;
; ==============================
; end of main loop
; ==============================
  NO_BOOT_PROG:
	call NEW_BLACK_SCREEN	; Очистить экран, установить черный фон - белый шрифт.  Курсор в 0,0
	ld de,NO_BOOT_MSG	; Уведомление об отсутствии в памяти программ для загрузки
	rst prn_scr
	jp KEY_INPUT		; Переходим на цикл опроса клавиатуры
;
; =============================
; Очистка экрана, установка 
; белого шрифта, фон черный
; -----------------------------
  NEW_BLACK_SCREEN:
	ld hl,0000h
	set 7,l
	call PRINT_SETPOS
	jp CLEAR_SCREEN		; Очистить экран
; =============================
; Очистка экрана, установка
; черного шрифта, белого фона
; -----------------------------
  NEW_WHITE_SCREEN:
	ld hl,0000h
	res 7,l
	call PRINT_SETPOS
	jp CLEAR_SCREEN		; Очистить экран
;
; =============================
; Установка конфигурации памяти
; -----------------------------
MEM_CONFIG:
	and 0c0h		; Оставим только биты конфигурации памяти
	ld b,a			; Сохраним запрошенную страницу памяти
	ld a,(ix+port_mode)
	and 3fh			; Сохраним все биты данных, кроме двух старших (P0-P3)
	or b			; Установим новую конфигурацию памяти
	out (CONFIG_PORT),a	; Запишем данные в порт
	ld (ix+port_mode),a	; И переменную
	ret
;
; =============================
; Воспроизведение звукового сигнала
; -----------------------------	
SYS_MERR_RADR:
	defw MERRRET
SYS_BEEP_MERR:
	ld hl,0000h
	add hl,sp		; В HL сохраним текущее значение SP
	ld sp, SYS_MERR_RADR
SYS_BEEP:	
	ld a,(ix+port_mode)	; Считаем текущую конфигурацию системного порта
SYS_BEEP1:
	ld c,0ffh		; длительность ожидания цикла
	xor 01h			; инвертируем бит в порту спикера
 	out (CONFIG_PORT),a	; выводим в порт
SYS_BEEP2:
	dec c			; уменьшаем счетчик			
	jr nz,SYS_BEEP2		; Повторяем паузу, пока 
	djnz SYS_BEEP1
	ret			; Завершаем подпрограмму
;
; =============================
; Test page memory
; -----------------------------
MEM_PAGE_TEST:
	pop de			; в DE сохраним адрес возврата (откуда производился вызов)
	pop bc			; в BC сохраним хранящиеся в стеке текущие координаты вывода на дисплей
	pop iy			; в IY сохраним количество протестированных страниц (в стеке)
	ld hl,0000h		; Подготовим HL для получения SP
	add hl,sp		; HL=Текущий указатель стека
	exx			; Хранить данные в альтернативных регистрах до завершения тестов
; выборка тестируемой страницы
	xor a			; Очистить регистр адреса порта
MEM_PAGE_NEXT:
	ld sp,MEM_PAGE_RET-2	; Установить указатель стека на адрес возврата для продолжения процедуры
	ld c,CONFIG_PORT	; Конфигурационный порт
	out (c),a		; Выбрать порт с адресом в 'A'
	ex af,af'		; Сохраним регистр адреса страниц
; вызов процедуры теста и возврат на MEM_PAGE_RET
	jp MTEST		; Перейти к тестированию памяти
	jp MEM_PAGE_RET		; Здесь прописан адрес возврата для продолжения работы. JP не исполяется
  MEM_PAGE_RET:
	dec hl			; по возврату из теста HL=0, нужен FFFF
	ex af,af'		; Восстановим регистр страниц
	ld (hl),a		; запишем в конец страницы её номер
	add 40h			; Увеличить номер страницы на 1 (0-3)
	jr nc,MEM_PAGE_NEXT	; Выолним цикл тестирования следующей страницы, пока не придём к 0-ой
; ------------------------------
	xor a			; Очистить регистр адреса порта
	ld b,a			; Обнулить счетчик доступных страниц
  MEM_PAGE_VERIFY:
	ld c,CONFIG_PORT	; Конфигурационный порт
	out (c),a
	cp (hl)
	jr z,MEM_PAGE_CSKIP	; Если да, то продолжить цикл
	out (0f2h),a		; В случае ошибок, выводить в ttyUSB код страницы
	ex af,af'
	ld a,(hl)
	out (0f2h),a		; и код записанный в странице
	ex af,af'
	dec b			; Каждую ошибку уменьшать счетчик страниц на 1
  MEM_PAGE_CSKIP:
	inc b			; Увеличить счетчик доступных страниц
	add 40h
	ex af,af'
	ld hl,mem_clear_area	; Начала области очищаемой памяти
  MEM_FULL_CLEAR:
	xor a
	ld (hl),a
	inc hl
	ld a,l
	or h
	jr nz,MEM_FULL_CLEAR
	dec hl			; Вернуть HL к значению FFFFh
	ex af,af'
	jr nc,MEM_PAGE_VERIFY
	xor a
	out (c),a		; включить базовую страницу
	ld a,b			; В A вернуть число доступных страниц памяти
; ------------------------------	
	exx
	ld sp,hl		; Вернём указатель стека на место
	push iy			; Вернём в стек количество страниц
	push bc			; Вернём туда координаты вывода на дисплей
	push de			; Вернём туда адрес возврата из теста страничной памяти
	ret
; -------------------------------
	include "interrupt.asm" ; Обработчик прерывания на адресе 0038h - сканирование клавиатуры
	include "display.asm"
	include "ps2_input.asm"
	include "key9_input.asm"
	include "memtotty.asm"
	include "i2c.asm"
	include "converse.asm"
	include "font.asm"
; -------------------------------
; SYSTEM MESSAGES		'
; -------------------------------
MERRSTR1:
	defb "ERR",0dh,0ah,00h
MERRSTR2:
	defb "A:0000 W:00,R:FF",0dh,0ah,00h
;! MERRSTR2_RAM:	equ variables_rom + 80h	; Область RAM для переноса сообщения об ошибке
   MERRSTR2_RAM:	equ STACK_POINT + 02h	; Область RAM для переноса сообщения об ошибке
MERRSTR3:
	defb "System halted.",00h
MTSTSTR1:
	defb "Base memory:",00h
MTSTSTR2:
	defb "OK",0dh,0ah,00h
MTSTSTR3:
	defb "Testing pages...",0dh,00h
MTSTSTR4:
	defb "0x16384Kb Found",0dh,0ah,00h
DBGMSTR1:
	defb "Debug enabled",0dh,0ah,00h
OFFSTR:
	defb "OFF",0dh,0ah,00h
ONSTR:
	defb "ON",0dh,0ah,00h
I2CMSG1:
	defb "Scaning i2c...",0dh,0ah,00h
I2CMSG2:
	defb " A:#00, ",00h
I2CMSG3:
	defb "i2c Bus busy.. ",0dh,00h
I2CMSG4:
	defb "i2c Not Ready..",0dh,00h
I2CDEVLIST:
	defb 00h
	defb 040h,"I/O EXP",00h
	defb 070h,"DISP/IO",00h
	defb 0a0h,"EEPROM ",00h
	defb 0c0h,"DAC    ",00h
	defb 090h,"ADC    ",00h
	defb 0d0h,"RTC    ",00h
	defb  00h,"Unknow ",00h
I2CFOUND:
	defb "Found:   ",00h
I2CFOUND2:
	defb " Dev. ",0dh,0ah,00h
ENDSTRING:
	defb 0dh,0ah,00h
EEPROM_MSG1:
	defb "Probe EEPROM:   ","Reading...",00h
EEPROM_MSG2:
	defb 0dh,0ah,"EEPROM Readed.",0dh,00h
EEPROM_MSG3:	
	defb ".  ",00h
EEPROM_MSG4:	
	defb ".. ",00h	
EEPROM_MSG5:	
	defb "...",00h
EEPROM_MSG6:	
	defb 0ah,"Files not found.",00h	
EEPROM_MSG7:
	defb 0dh,"Press (N)ext forsearching files in next EEPROM.",0dh,0ah,"Warning! Search files may damagethe contents of the EEPROM!",0dh,0ah,00h
ROM_LOADING:
	defb 0ah,"Press 'ENTER' or'#'for boot fromROM BIOS.",00h
NO_BOOT_MSG:
	defb "No boot program in ROM found.",0dh,0ah,0ah,"Nothing to do..",00h
PRG_NUM_BYTE:
	defb 00h
CONV_BUFF:
	defs 05h,00h

	include "rom_mod-prg.asm"
	include "rom_mod-mon.asm"
;	include "rom_mod-read.asm"	
;	include "rom_mod-osc.asm"
;	include "pcf_illuminate.asm"
; -------------------------------
; ТЕКСТОВЫЙ БУФЕР ВНЕ ROM - всё что после него - не копируется !!
	org variables_set+80h		; Текстовый буфер 160 байт, размещается сразу за областью переменных (первые 128 байт)
TEXT_BUFFER:
;	defs 0a0h,20h			; !! Заполнение не используем, так как Ассемблер выполняет его сразу после include, а не по адресу TEXT_BUFFER!!!
; -------------------------------

end