;scan_lowbyte:	equ 0bh	;	= 00
;scan_highbyte:	equ 0ch	;	= 01
;scan_count:	equ 0dh	;	= 02
;scan_stcount:	equ 0eh	;	= 03
;scan_mb_line:	equ 0fh	;	= 04
;scan_top_line:	equ 10h	;	= 05
scan_code:	equ 11h	;	= 06
scan_lcode:	equ 13h	;	= 08
scan_repcnt:	equ 14h	;	= 09
int_count:	equ 16h	;	= 0a
input_len:	equ 22h	;	Содержит количество вводимых символов (управляющие коды не учитываются)
input_crlen:	equ 23h ;	Содержит количество введёных символов (Управляющие коды не учитываются)
input_buf_l:	equ 24h ;	Содержит младший байт адреса буфера ввода
input_buf_h:	equ 25h	;	Содержит старший байт адреса буфера ввода
; ==============================
; Keyboard input loop
; ==============================
KEY_INPUT:
	ld (ix+input_crlen),00h	; Инициализируем счетчик введёных символов (00)
	jr KEY_INPUT2		; Перейти к  ожиданию прерывания
KEY_INPUT1:
	ld (ix+scan_lcode),a	; Сохранить последний считанный код
KEY_INPUT2:
	halt			; Ожидаем прерываение
	push hl
	push de
	push bc
	call PS2CODE_CONVERT
	pop bc
	pop de
	pop hl
	call KEY_CURSOR
	ld a,(ix+scan_code)	; Читаем содержимое
	or a			; Проверяем на 0
	jr z,KEY_INPUT1		; Если считан "0", сохраняем считанный результат и ждём следующее прерывание, иначе
; 110815-14:08 Добавлено для очистки, если нажата любая кнопка
	push hl
	push de
	ld a,20h		; Загружаем код "пробела"
	call SYM_DRAW		; Вызываем отрисовку символа по в текущей (HL) позиции
	pop de
	pop hl
; Конец вставки 110815-14:08

; 161216-13:55 Добавлено для ограничения поля ввода
	ld a,(ix+scan_code)	; Проверяем принятый скан=код
	cp 1bh			; Это ESC ?
	jr z,KEY_INPUT6		; Если это ESC, тоже записать в буфер 00h и выйти, но A будет содержать код ESC
	cp 0bh			; Это стрелка вниз ?
	jr z,KEY_INPUT2		; Если это стрелка вниз, ждем ввода следующего символа
	cp 18h			; Это стрелка вверх ?
	jr z,KEY_INPUT2		; Если это стрелка вниз, ждем ввода следующего символа
	cp 0ah
	jr nz,KEY_INPUT10	; Если это не ENTER, продолжим обработку. Иначе записать в текущий адрес буфера 00h и выйти

	ld a,(ix+input_crlen)	; Количество введёных символов
	or a
KEY_INPUT6:
	ld l,(ix+input_buf_l)
	ld h,(ix+input_buf_h)
	ld (hl),00h		; Запись по текущему адресу код конца строки
	ret 			; Если введены какие-либо символы, выходим A=число символов (Z+0-сразу нажат ENTER). Z+A=1b - Escape, NZ+N - число символов
KEY_INPUT10:
	cp 7fh			; Проверяем на '#'
	jr z,KEY_INPUT5
	cp 08h			; Проверяем на BACKSPACE
KEY_INPUT5:	
	ld a,(ix+input_crlen)	; Количество введёных символов
	jr nz,KEY_INPUT7	; Если не BACKSPACE, то переходим к проверке превышения поля ввода, иначе проверяем на начало поля ввода
	or a			; Находимся в начальной позиции ?
	jr z,KEY_INPUT2		; Если да, то переходим ожиданию нового символа, так как удалять уже нечего
KEY_INPUT7:
	cp (ix+input_len)	; Общая длина ввода
	ld a,(ix+scan_code)	; Загружаем в A код символа
	jr c,KEY_INPUT8		; Если ещё осталось место для ввода, то обработать данные, иначе
	cp 08h
	jr z,KEY_INPUT8		; Если это 'Del', то обработать код, иначе идём новый код без обработки текущего
	cp 7fh
	jr z,KEY_INPUT8		; Если это '#', то обработать код, иначе идём новый код без обработки текущего
	jr KEY_INPUT2
KEY_INPUT8:
; 161216-13:55
	cp (ix+scan_lcode)	; Сравнить с предыдущим считанным кодом 
	jr z,KEY_INPUT3		; Если да, перейти на проверку автоповтора, иначе
	ld de,variables_set+scan_code
	push af			; Сохранить код считанного символа
	call PRN_WSCROLL	; Выводим на экран считанный символ (строку из 1-го символа) в "текущее" местоположение.
	ld b,06h		; Загружаем количество импульсов звука нажатия клавиши. Число должно быть чётным!!!
	call SYS_BEEP		; Воспроизводим звук нажатия
	ld a,19h		; Установить паузу 25/25 перед началом автоповтора
	ld (ix+scan_repcnt),a	; Установить задержку перед повтором
	pop af			; Восстановить код считанного символа
	call KEY_INPBUFF
	jr KEY_INPUT1		; Перейти к сохранению последнего считанного кода и ожиданию прерывания
KEY_INPUT3:
	ld a,(ix+scan_repcnt)	; Читаем значение счетчика
	or a			; Счетчик равен 0 ?
	jr z,KEY_INPUT4		; Если равен нулю перейдём к выводу символа и загрузке счетчика автоповтора, иначе
	dec (ix+scan_repcnt)	; уменьшим значение счетчика на 1
	jp KEY_INPUT2		; Перейдём к ожиданию следующего прерывания
KEY_INPUT4:
	ld (ix+scan_repcnt),02h	; Установить паузу 2/25 для автоповтора (HL=8009h)
	ld de,variables_set+scan_code
	ld a,(de)
	call KEY_INPBUFF
	call PRN_WSCROLL	; Выводим на экран считанный символ (строку из 1-го символа) в "текущее" местоположение
	ld b,06h		; Загружаем количество импульсов звука нажатия клавиши. Число должно быть чётным!!!
	call SYS_BEEP		; Воспроизводим звук нажатия
	jp KEY_INPUT2		; Перейдем к ожиданию прерывания

; 161216-13:55 Добавлено для ограничения поля ввода	
KEY_INPBUFF:
	push hl
	ld l,(ix+input_buf_l)
	ld h,(ix+input_buf_h)
	cp 08h
	jr z,KEY_INPDEL
	cp 7fh
	jr z,KEY_INPDEL
	inc (ix+input_crlen)	; Увеличить на 1 счётчик введеных символов	
	ld (hl),a
	inc hl			; Увеличить на 1 байт адрес в буфере ввода
	ld (ix+input_buf_l),l
	ld (ix+input_buf_h),h
	pop hl
	ret
KEY_INPDEL:
	dec (ix+input_crlen)	; Уменьшить на 1 счётчик введёных символов	
	dec hl			; Увеличить на 1 байт адрес в буфере ввода
	ld (ix+input_buf_l),l
	ld (ix+input_buf_h),h
	pop hl
	ret
; 161216-13:55
KEY_CURSOR:
; 110815-13:34 Добавлено для отображения курсора
	push hl			; Сохранить актуальную позицию и атрибуты
	ld a,(ix+int_count)	; Считать состояние счетчика прерываний
	and 08h			; Выделить состояние 3-го бита
	set 7,l			; Включим инверсию
	jr nz,KEY_CURSOR1	; Если bit3 установлен, включим режим инверсии, иначе
	res 7,l			; Сбросим режим инверсии
KEY_CURSOR1:
	and 07h			; Проверить значение счетчика. 
	jr nz,KEY_CURSOR2	; Если оно не кратно 8, обойти цикл отрисовки курсора
	ld a,20h		; Код пробела на отрисовку
	call SYM_DRAW		; Отобразить симовол
KEY_CURSOR2:
	inc (ix+int_count)	; Увеличить счетчик на 1
	pop hl			; Восстановить актуальную позицию и атрибуты
; Конец вставки 110815-13:34
	ret

;!!!!!!!!!!!!!!!!!!!!! Это фрагмент кода обработчика прерываний. Размещён отдельно из-за коротких переходов в MEMORY.ASM	
;
; Scancode building
;
SCODE_BUILD:
	call KEY_DECODE		; Определить номер нажатой клавиши, если нажатых нет, то = "0"
	ld a,b			; Сохраняем в регистре 'B' номер нажатой клавиши. 0, если ничего не нажато
	jr c,SCODE_SAVE		; Если обнаружено нажатие любой из клавиш в строке -> Сохраняем её номер и выходим
	ld a,(ix+scan_mb_line)	; Читаем коды
	and 0fh			; Оставляем только среднюю линию
	call KEY_DECODE		; В "B" номер нажатой клвиши. 0, если ничего не нажато
	jr nc,SCODE_L0		; Если нажатие не обнаружено переходим к проверке следующей строки, иначе
	ld a,04h		; загружаем в "А" 4 и 
	add b			; суммируем со считанным кодом. В регистре "А" получаем номер клавиши от 5-8
	jr SCODE_SAVE		; Если было обнаружено нажатие любой из клавиш в строке -> Сохраняем её номер и выходим
SCODE_L0:
	ld a,(ix+scan_mb_line)	; вновь читаем сканкоды
	srl a			; \
	srl a			; |
	srl a			; | - четыре старших бита двигаем в четыре младших разряда,  старшие заполняем нулями
	srl a			; /
	call KEY_DECODE		; В "B" номер нажатой клавиши. 0, если ничего не нажато
	jr nc, SCODE_SAVE	; Если нажатие не обнаружено, перейти к сохранению текущего кода ("0")
	ld a,08h		; Иначе добавим основу 8
	add b			; И сложим со считанным кодом
SCODE_SAVE:
	ld hl,SCODE_TABLE	; В HL адрес начала таблицы преобразования кодов клавиатуры
	ld c,a			; В регистр "С" номер клавиши
	ld b,00h		; BC = смещение в таблице преобразования
	add hl,bc		; К началу таблицы прибавить считанный код (на первом месте код "0")
	ld a,(hl)		; Читаем из таблицы соответствующий сканкод
	ld (ix+scan_code),a	; Сохраняем сканкод
	ret			; Вернуться в подпрограмму сканирования для завершения обработки прерывания
; decoding number pressed key
KEY_DECODE:
	ld b,04h		; Загружаем количество клавиш в строке
SCODE_L1:
	rrca			; Сдвигаем регистр вправо
	ret c			; Если обнаруживаем нажатие - выходим из цикла
	djnz SCODE_L1		; Иначе уменьшаем регистр B
	ret			; Если дошли до 0 и ничего не обнаружили нажатым, выходим с нулём и флагом NC
	
; -------------------------------
; THE KEYBORD SCANCODE TABLE SET'
; -------------------------------
;
SCODE_TABLE:
	defb 00h,"*","7","4","1","0","8","5","2",7fh,"9","6","3"
	
;
; PS2 layout convertor
;
PS2CODE_CONVERT:
	ld hl,PS2_BUFCNT	; HL счетчик позиции
	ld de,PS2_BUFFER	; DE Адрес начала буфера
	ld a,(PS2_MAXBUFSIZE)	; загрузим значение счетчика
	cp (hl)			; если буфер позиция счетчика = максимальному размеру буфера, то
	ret z			; буфер пуст, выход из процедуры
	ld c,a
	inc (hl)		; Увеличить значение счетчика буфера
	ld b,0
	ex de,hl
	add hl,bc		; Вычисляем адрес конца (начала данных) буфера
	ld a,(hl)		; Взяли оттуда сканкод
	push hl
	push bc
	call PS2CODE_SEEK	; Ищем его в таблица
	pop bc
	pop hl
	ld d,h
	ld e,l			; DE=HL
	dec hl
	lddr			; Сдвинуть блок BC раз на байт к концу  (HL) -> (DE)  -HL, -DE  
	ret			; Закончить процедуру
	
PS2CODE_SEEK:
	ld hl,PS2_FLAGS
	cp 012h
	call z,PS2CODE_SHIFT
	cp 059h
	call z,PS2CODE_SHIFT
	cp 011h
	call z,PS2CODE_ALT
	cp 014h
	call z,PS2CODE_CTRL
	bit 7,(hl)
	jr nz,PS2CODE_F0_CLEAR
	cp 058h
	jr z,PS2CODE_CAPS
	cp 0f0h
	jr z,PS2CODE_F0	
	cp 0e0h
	jr z,PS2CODE_E0
	bit 5,(hl)		; SHIFT нажат ?
	jr z,PS2CODE_SEEK_NOSHIFT
	or 80h			; Хрен с ней с F7 )))),  все остальные имеют коды меньше 80h
PS2CODE_SEEK_NOSHIFT:
	bit 2,(hl)
	jr z,PS2CODE_SEEK_NOCAPS
	xor 80h
PS2CODE_SEEK_NOCAPS:
;	bit 0,(hl)		; Проверим раскладку клавиатуры
	ld c,a
	ld b,0
	ex de,hl
	ld hl,PS2_LAYOUT_TABLE	
;	jr z,PS2CODE_MAIN_LAY	; Если основная раскладка, перейдём к определению конечного адреса таблицы
;	inc b			; Если раскладка дополнительная, добавим 256 к началу таблицы преобразования
;PS2CODE_MAIN_LAY:	
	add hl,bc
	ld a,(hl)
	ld (ix+scan_code),a
	ex de,hl
	res 6,(hl)		; Сбросить признак расширенных данных (передварительно использовать его для преобразования кодов
	ret
PS2CODE_F0:
	set 7,(hl)		; Установить признак полученного кода отмены
	ret			; Выход из процедуры без преобразования кода
PS2CODE_F0_CLEAR:
	res 7,(hl)		; Сбросить флаг отмены кода #F0
	ret			; Выход из процедуры без преобразования полученного кода
PS2CODE_E0:
	ld a,01000000b		; Будем инвертировать признак наличия кода расширения
	xor (hl)		; Инвертировать bit последовательности расширенных кодов
	ld (hl),a		; Сохранить результат
	ret			; Выход из процедуры без преобразования кодов
PS2CODE_SHIFT:
	bit 7,(hl)		; SHIFT нажат или отпущен ?
	jr z, PS2CODE_SHIFT_ON	; Если F0 небыло -> Нажатие
	res 5,(hl)		; Иначе это отпускание SHIFT-а
	bit 3,(hl)		; В момент отпускания SHIFT, ALT был нажат ?
	ret z			; Если небыл, то выходим, иначе переключим раскладку
	ld a,(hl)
	xor 1			; Сменим флаг раскладки на противоположный
	ld (hl),a
	ret
PS2CODE_SHIFT_ON:
	set 5,(hl)		; Установить признак нажатия SHIFT
	ret
PS2CODE_CAPS:
	ld a,00000100b		; bit2 - CAPS
;	- Вставить ON/OFF CAPS LED
	xor (hl)
	ld (hl),a		; инвертировать флаг
	ret
PS2CODE_CTRL:
	bit 7,(hl)		; CTRL нажат или отпущен ?
	jr z, PS2CODE_ALT_ON	; Если F0 небыло -> Нажатие
	res 4,(hl)		; Иначе это отпускание CTRL-а
PS2CODE_CTRL_ON:
	set 4,(hl)		; Установить признак нажатия PS2CODE_CTRL
	ret
PS2CODE_ALT:
	bit 7,(hl)		; ALT нажат или отпущен ?
	jr z, PS2CODE_ALT_ON	; Если F0 небыло -> Нажатие
	res 3,(hl)		; Иначе это отпускание ALT-а
	ret
PS2CODE_ALT_ON:
	set 3,(hl)		; Установить признак нажатия PS2CODE_ALT
	ret
	
	
PS2_MAXBUFSIZE:
	defb 1fh		; Максимальный размер буфера	- !Работает только после переноса в Shadow_RAM!!
PS2_FLAGS:
	defb 00h		; регистр флагов состояния	- !Работает только после переноса в Shadow_RAM!!
				; bit7 - прежде получен код #F0
				; bit6 - прежде получен код расширения #E0
				; bit5 - зажат Shift (L/R)
				; bit4 - зажат CTRL (L/R)
				; bit3 - зажат ALT (L/R)
				; bit2 - включен CAPS
				; bit1 - включен NUMLOCK
				; bit0 - раскладка (LAT/RUS)
	
PS2_LAYOUT_TABLE:
	defb 00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,09h,00h,"`",00h,00h,00h,00h,00h,00h,"q","1",00h,00h,00h,"z","s","a","w","2",00h	; 00-1F
	defb 00h,"c","x","d","e","4","3",00h,00h,20h,"v","f","t","r","5",00h,00h,"n","b","h","g","y","6",00h,00h,00h,"m","j","u","7","8",00h	; 20-3F
	defb 00h,",","k","i","o","0","9",00h,00h,".","/","l",";","p","-",00h,00h,00h,00h,00h,"[","=",00h,00h,00h,00h,0ah,"]",00h,5ch,00h,00h	; 40-5F
	defb 00h,00h,00h,00h,00h,00h,08h,00h,00h,00h,00h,00h,00h,00h,"~",00h,00h,00h,0bh,00h,00h,18h,1bh,00h,00h,00h,00h,00h,00h,00h,00h,00h	; 60-7F	;Дополнение от 120117, Стрелка вниз 72h - код 0bh, Стрелка вверх 75h - код 18h
	defb 00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,09h,00h,00h,00h,00h,00h,00h,00h,00h,"Q","!",00h,00h,00h,"Z","S","A","W","@",00h	; 80-9F
	defb 00h,"C","X","D","E","$","#",00h,00h,20h,"V","F","T","R","%",00h,00h,"N","B","H","G","Y","^",00h,00h,00h,"M","J","A","&","*",00h	; A0-BF
	defb 00h,"<","K","I","O",")","(",00h,00h,">","?","L",":","P","_",00h,00h,00h,00h,00h,"{","+",00h,00h,00h,00h,0ah,"}",00h,7ch,00h,00h	; C0-DF
	defb 00h,00h,00h,00h,00h,00h,08h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,1bh,00h,00h,00h,00h,00h,00h,00h,00h,00h	; E0-FF
