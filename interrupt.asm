scan_lowbyte:	equ 0bh	;	= 00
scan_highbyte:	equ 0ch	;	= 01
scan_count:	equ 0dh	;	= 02
scan_stcount:	equ 0eh	;	= 03
scan_mb_line:	equ 0fh	;	= 04
scan_top_line:	equ 10h	;	= 05
;
; Keyboard scan driver Interrput at base 0038h
;				  Обработчик прерывания. Сохраняем все задействованные регистры. Выход по EI,RET
INT38:
	push af			; \
	ex af,af'		; |
	push af			; |
	push hl			; |
	push bc			; | - Сохраняем все регистры
	push de			; /
; Вставка чтения клавиатуры PS/2	12-10-2016
	call PS2_READ		; Вызываем процедуру чтения PS/2 клавиатуры
	ld a,(PS2_RAWDATA)	; Проверяем состояние линии CLOCK
	bit 2,a			; Если CLOCK = 0, значит в этом прерывании обрабатывалась PS/2
	jr nz,KEYSCAN0		; Обходим стандартную обработку, если прерывание было по сигналу CLOCK от PS/2
	ld b, 010h		; Пауза перед выходом из прерывания
KEYLOOP:
	djnz KEYLOOP		; Выдерживаем паузу - корректировка ошибки схемы прерываний -> Длительность импульса может превышать продолжительность обработки прерывания
	jr KEYSCAN4		; Завершаем прерывание без обработки T12
KEYSCAN0:
; Конец вставки 			12-10-2016
	ld bc,7ffeh		; В BC Адрес порта ввода клавиатуры (#FE) и строки (#7F)
	in a,(c)		; Читаем содержимое порта
	sla a			; \
	sla a			; | - Циклическое смещение считанного байта влево
	sla a			; |
	sla a			; /
	ld e,a			; Сохраняем полученный результат в регистре E
	rrc b			; Циклическое смещение регистра B вправо (выбираем следующую строку клавиатуры)
	in a,(c)		; Читаем содержимое порта
	and 0fh			; Сбрасывваем незначащие 4 старших бита данных
	or e			; Объединяем со считанными ранее данными
	cp (ix+scan_lowbyte)	; Сравниваем с прежним результатом сканирования клавиатуры			
	jr z,KEYSCAN1		; Если считан тот же код, то проходим дальше, иначе загрузить новое значение и перезагрузить счетчик
	ld (ix+scan_lowbyte),a	; Сохраняем новое значение по адресу xxx0h
	ld a,(ix+scan_stcount)	; Исходное значение счетчика
	ld (ix+scan_count),a	; Переносим в переменную счетчика
KEYSCAN1:
	rrc b			; Циклическое смещение регистра B вправо (выбираем следующуб строку клавиатуры)
	in a,(c)		; Читаем содержимое порта
	and 0fh			; Сбрасываем незначащие 4 старших бита данных
	cp (ix+scan_highbyte)	; Сравниваем с прежним результатом скана
	jr z,KEYSCAN2		; Если изменений нет, идём далее, иначе загружаем новое значение и перезагружаем счетчик
	ld (ix+scan_highbyte),a	; Сохраняем новое значение по адресу xxx1h
	ld a,(ix+scan_stcount)	; Исходное значение счетчика
	ld (ix+scan_count),a	; Переносим в переменную счетчика
KEYSCAN2:
	dec (ix+scan_count)	; Уменьшаем содержимое переменной с адресом xxx2h на 1
	jr nz,KEYSCAN3		; Если содержимое счетчика <>0, не загружаем счетчик вновь
	ld a,(ix+scan_stcount)	; Исходное значение счетчика
	ld (ix+scan_count),a	; Сохраняем в переменную счетчика (xxx2h)
	ld a,(ix+scan_lowbyte)	; Считать младший байт клавиатуры
	cpl			; Инвертировать данные
	ld (ix+scan_mb_line),a	; Сохранить в переменной1 результат скана средней и нижней строк
	ld a,(ix+scan_highbyte)	; Считать старший байт клавиатуры
	or 0f0h			; Дополнить старшие 4 разряда 
	cpl			; Инвертировать данные
	ld (ix+scan_top_line),a	; Сохранить в переменной2 результат скана верхней строки
	call SCODE_BUILD
KEYSCAN3:
	ld a,(ix+fr_buffer_on)	; Считаем режим работы кадрового буфера
	or a			; Кадровый буфер включен в прерывании ?
	call nz,MTD_INT		; Если да, то копируем в каждом прерывании содержимое буфера
KEYSCAN4:
	pop de			;\
	pop bc			;|
	pop hl			;| - Восстанавливаем все задействованные регистры
	pop af			;|
	ex af,af'		;|
	pop af			;/
	ei			; Вновь разрешаем прерывания
	ret			; выходим из немаскируемого прерывания режима IM1 (в случае IM2 используем RETI)
